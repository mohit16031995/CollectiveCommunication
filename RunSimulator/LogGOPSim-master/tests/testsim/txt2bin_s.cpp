/* Generated by re2c 0.13.5 on Wed Oct 15 16:13:08 2014 */
#line 1 "txt2bin.re"
#include <map>
#include <math.h>
#include <string>
#include <limits>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>

#include "Goal.hpp"
#include "cmdline_txt2bin.h"

typedef unsigned int uint;
typedef unsigned char uchar;

#define	BSIZE	10240

#define	YYCTYPE		uchar
#define	YYCURSOR	cursor
#define	YYLIMIT		s->lim
#define	YYMARKER	s->ptr
#define	YYFILL(n)	{cursor = fill(s, cursor, n);}


#define OPT_USE_ONCE 1
#define OPT_OVERFLOW_LIST 2
#define OPT_PRIORITY_LIST 4


#define	RET(i)	{s->cur = cursor; return i;}

gengetopt_args_info args_info;

typedef struct Scanner {
    FILE*		fd;
    uchar		*bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint		line;
	int			rank;
	uint32_t 	curr_rank, num_ranks;
	Goal*		schedule;
	std::map<std::string, goalop_t>* idtbl;
} Scanner;

typedef struct Item {
	char type;
	char *label1;
	char *label2;
	uint64_t size;
	uint32_t target;
	uint32_t tag;
	uint8_t cpu;
	uint8_t nic;
	char options;
	uint32_t ct;
	uint64_t threshold;
} Item;

enum OpTypes {
	Undefined,
	SendOp,
	RecvOp,
	LoclOp,
	StartDependency,
	Dependency,
	AppendOp,
	PutOp,
	GetOp,
	CTWaitOp,
	tAppendOp,
	tPutOp,
	tGetOp
};

inline uint64_t add_number(unsigned char *s, unsigned char *e) {

	uint64_t num = 0;
	--s;
	while(++s < e) num = num * 10 + (*s - '0');

	return num;
}

inline void insert_id(Scanner *s, char *id, goalop_t op) {

	s->idtbl->insert(std::make_pair(std::string(id), op));
	free(id);
}

inline goalop_t retrieve_id(Scanner *s, char *id) {

	std::map<std::string, goalop_t>::iterator it;
	it = s->idtbl->find(std::string(id));
	if (it == s->idtbl->end()) {
		fprintf(stderr, "A dependency references label %s, which is undefined!\n", id);
		exit(EXIT_FAILURE);
	}
	free(id);
	return it->second;
}

void process_item(Scanner *s, Item *item) {

/*
	printf("Parsed Item:\n");
	printf("  Type: ");
	if (item->type == Undefined) printf("Undefined\n");
	if (item->type == SendOp) printf("Send\n");
	if (item->type == RecvOp) printf("Recv\n");
	if (item->type == LoclOp) printf("LoclOp\n");
	if (item->type == StartDependency) printf("IRequires\n");
	if (item->type == Dependency) printf("Requires\n");
	printf("  Label1: %s\n", item->label1);
	printf("  Label2: %s\n", item->label2);
	printf("  Size: %i\n", item->size);
	printf("  Target: %i\n", item->target);
	printf("  Tag: %i\n", item->tag);
	printf("  CPU: %i\n", item->cpu);
	printf("  NIC: %i\n", item->nic);
*/

	goalop_t op, op2;

	switch (item->type) {
		case Undefined:
			fprintf(stderr, "Error while parsing, attempt to add a undefined operation\n");
			exit(EXIT_FAILURE);
			break;
		case SendOp:
			op = s->schedule->Send(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case RecvOp:
			op = s->schedule->Recv(item->target, s->rank, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case LoclOp:
			op = s->schedule->Calc(s->rank, item->size, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
        case PutOp:
            op = s->schedule->Put(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case GetOp:
            op = s->schedule->Get(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case AppendOp:
            op = s->schedule->Append(s->rank, item->target, item->size, item->tag, item->options, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case CTWaitOp:
            op = s->schedule->CTWait(s->rank, item->ct, item->size, item->cpu);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tAppendOp:
            op = s->schedule->tAppend(s->rank, item->target, item->size, item->tag, item->options, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tPut:
            op = s->schedule->tPut(s->rank, item->target, item->size, item->tag, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tGet:
            op = s->schedule->tGet(s->rank, item->target, item->size, item->tag, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
		case StartDependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->StartDependency(op, op2);
			break;
		case Dependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->Dependency(op, op2);
			break;
		default:
			break;
	}
}

inline char* add_label(unsigned char *s, unsigned char *e) {

	char *buf = NULL;

	buf = (char *) malloc((e-s)+1);
	memcpy((void *) buf, (void *) s, (size_t) (e-s));
	buf[e-s] = '\0';

	return buf;

}


uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	if(!s->eof) {
		uint cnt = s->tok - s->bot;
		if(cnt){
			if ((s->lim - s->tok) < abs(s->bot - s->tok)) memcpy(s->bot, s->tok, s->lim - s->tok);
			else memmove(s->bot, s->tok, s->lim - s->tok);
			s->tok = s->bot;
			s->ptr -= cnt;
			cursor -= cnt;
			s->pos -= cnt;
			s->lim -= cnt;
		}
		if((s->top - s->lim) < BSIZE){
			uchar *buf = (uchar*) malloc(((s->lim - s->bot) + BSIZE)*sizeof(uchar));
			if ((s->lim - s->tok) > abs(s->tok - buf)) memmove(buf, s->tok, s->lim - s->tok);
			else memcpy(buf, s->tok, s->lim - s->tok);
			s->tok = buf;
			s->ptr = &buf[s->ptr - s->bot];
			cursor = &buf[cursor - s->bot];
			s->pos = &buf[s->pos - s->bot];
			s->lim = &buf[s->lim - s->bot];
			s->top = &s->lim[BSIZE];
			free(s->bot);
			s->bot = buf;
		}
		cnt = fread((char*) s->lim, 1, BSIZE, s->fd);
		if(cnt != BSIZE) {
			s->eof = &s->lim[cnt];
			*(s->eof)++ = '\n';
		}
		s->lim += cnt;
		//assert(cnt >= numtoread);
	}
	return cursor;
}

/*
uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	static bool firstcall = true;

	if (firstcall) {

		void *buf;
		struct stat statbuf;

		int ret = fstat(fileno(s->fd), &statbuf);
		buf = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fileno(s->fd), 0);
		assert(buf != NULL);
		s->lim = (uchar*) buf;
		s->lim += statbuf.st_size;
		s->eof = s->lim;
		return (uchar*) buf;
	}
	else {
		assert(0==1);
	}
}
*/

int scan(Scanner *s) {

	//uchar *cursor = s->cur;

	static uchar *cursor = NULL;
	Item item;
	int state;

	for (;;) {

s_0:

	if ((cursor == s->eof) and (cursor != NULL)) {
		fprintf(stderr, "Reached the end of the inputfile - did you forget a closing bracket?\n");
		return s->rank;
	}

	s->tok = cursor;
	state = 0;

	// printf("Entered s_0\n");
	// if (((s->line % 100) == 0) or (s->line < 100)) printf("Line: %i\n", s->line);

	item.type = Undefined;
	item.label1 = NULL;
	item.label2 = NULL;
	item.cpu = 0;
	item.nic = 0;
	item.tag = 0;
	item.options = 0;
	item.ct = 0;
	item.threshold = 0;


#line 303 "txt2bin_s.cpp"
		{
			YYCTYPE yych;

			if ((YYLIMIT - YYCURSOR) < 12) YYFILL(12);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy2;
			case '\n':	goto yy17;
			case '\r':	goto yy16;
			case '/':	goto yy14;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'q':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy9;
			case 'a':	goto yy10;
			case 'c':	goto yy7;
			case 'g':	goto yy11;
			case 'n':	goto yy8;
			case 'p':	goto yy12;
			case 'r':	goto yy6;
			case 's':	goto yy4;
			case 't':	goto yy13;
			case '}':	goto yy19;
			default:	goto yy21;
			}
yy2:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy80;
yy3:
#line 344 "txt2bin.re"
			{ s->tok = cursor; }
#line 377 "txt2bin_s.cpp"
yy4:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 'e':	goto yy75;
			default:	goto yy31;
			}
yy5:
#line 350 "txt2bin.re"
			{ item.label1 = add_label(s->tok, cursor); goto s_1; }
#line 387 "txt2bin_s.cpp"
yy6:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy67;
			case 'e':	goto yy68;
			default:	goto yy31;
			}
yy7:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy63;
			default:	goto yy31;
			}
yy8:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy54;
			default:	goto yy31;
			}
yy9:
			yych = *++YYCURSOR;
			goto yy31;
yy10:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy49;
			default:	goto yy31;
			}
yy11:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy47;
			default:	goto yy31;
			}
yy12:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy45;
			default:	goto yy31;
			}
yy13:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy29;
			case 'g':	goto yy27;
			case 'p':	goto yy28;
			default:	goto yy31;
			}
yy14:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '*':	goto yy23;
			case '/':	goto yy25;
			default:	goto yy15;
			}
yy15:
#line 365 "txt2bin.re"
			{ goto s_err; }
#line 446 "txt2bin_s.cpp"
yy16:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy22;
			default:	goto yy15;
			}
yy17:
			++YYCURSOR;
yy18:
#line 363 "txt2bin.re"
			{ s->line++; continue; }
#line 458 "txt2bin_s.cpp"
yy19:
			++YYCURSOR;
#line 364 "txt2bin.re"
			{ if (s->rank == -1) goto s_err; int oldrank = s->rank; s->rank = -1; return oldrank; }
#line 463 "txt2bin_s.cpp"
yy21:
			yych = *++YYCURSOR;
			goto yy15;
yy22:
			yych = *++YYCURSOR;
			goto yy18;
yy23:
			++YYCURSOR;
#line 352 "txt2bin.re"
			{ goto s_24; }
#line 474 "txt2bin_s.cpp"
yy25:
			++YYCURSOR;
#line 351 "txt2bin.re"
			{ goto s_23; }
#line 479 "txt2bin_s.cpp"
yy27:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy43;
			default:	goto yy31;
			}
yy28:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy41;
			default:	goto yy31;
			}
yy29:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy32;
			default:	goto yy31;
			}
yy30:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy31:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy5;
			}
yy32:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy33;
			default:	goto yy31;
			}
yy33:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy34;
			default:	goto yy31;
			}
yy34:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy35;
			default:	goto yy31;
			}
yy35:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy36;
			default:	goto yy31;
			}
yy36:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy37;
			default:	goto yy31;
			}
yy37:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy38;
			default:	goto yy31;
			}
yy38:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy39;
			default:	goto yy31;
			}
yy39:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy40;
			default:	goto yy31;
			}
yy40:
			yych = *++YYCURSOR;
			goto yy31;
yy41:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy42;
			default:	goto yy31;
			}
yy42:
			yych = *++YYCURSOR;
			goto yy31;
yy43:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy44;
			default:	goto yy31;
			}
yy44:
			yych = *++YYCURSOR;
			goto yy31;
yy45:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy46;
			default:	goto yy31;
			}
yy46:
			yych = *++YYCURSOR;
			goto yy31;
yy47:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy48;
			default:	goto yy31;
			}
yy48:
			yych = *++YYCURSOR;
			goto yy31;
yy49:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy50;
			default:	goto yy31;
			}
yy50:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy51;
			default:	goto yy31;
			}
yy51:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy52;
			default:	goto yy31;
			}
yy52:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy53;
			default:	goto yy31;
			}
yy53:
			yych = *++YYCURSOR;
			goto yy31;
yy54:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy55;
			default:	goto yy31;
			}
yy55:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy56;
			default:	goto yy31;
			}
yy56:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy57;
			default:	goto yy31;
			}
yy57:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy58;
			default:	goto yy31;
			}
yy58:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy59;
			default:	goto yy31;
			}
yy59:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy60;
			default:	goto yy31;
			}
yy60:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy61;
			default:	goto yy31;
			}
yy61:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy62;
			}
yy62:
#line 349 "txt2bin.re"
			{ goto s_22; }
#line 796 "txt2bin_s.cpp"
yy63:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy64;
			default:	goto yy31;
			}
yy64:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy65;
			default:	goto yy31;
			}
yy65:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy66;
			}
yy66:
#line 347 "txt2bin.re"
			{ item.type = LoclOp;  goto s_3; }
#line 880 "txt2bin_s.cpp"
yy67:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy72;
			default:	goto yy31;
			}
yy68:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy69;
			default:	goto yy31;
			}
yy69:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy70;
			default:	goto yy31;
			}
yy70:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy71;
			}
yy71:
#line 346 "txt2bin.re"
			{ item.type = RecvOp;  goto s_2; }
#line 970 "txt2bin_s.cpp"
yy72:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy73;
			default:	goto yy31;
			}
yy73:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy74;
			}
yy74:
#line 348 "txt2bin.re"
			{ goto s_20; }
#line 1048 "txt2bin_s.cpp"
yy75:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy76;
			default:	goto yy31;
			}
yy76:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy77;
			default:	goto yy31;
			}
yy77:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy30;
			default:	goto yy78;
			}
yy78:
#line 345 "txt2bin.re"
			{ item.type = SendOp;  goto s_2; }
#line 1132 "txt2bin_s.cpp"
yy79:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy80:
			switch (yych) {
			case '\t':
			case ' ':	goto yy79;
			default:	goto yy3;
			}
		}
#line 366 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_1:
	state =1;

	// printf("Entered s_1\n");


#line 1155 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy83;
			case ':':	goto yy85;
			case 'i':	goto yy89;
			case 'r':	goto yy87;
			default:	goto yy90;
			}
yy83:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy110;
yy84:
#line 376 "txt2bin.re"
			{ goto s_1; }
#line 1175 "txt2bin_s.cpp"
yy85:
			++YYCURSOR;
#line 377 "txt2bin.re"
			{ goto s_4; }
#line 1180 "txt2bin_s.cpp"
yy87:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy101;
			default:	goto yy88;
			}
yy88:
#line 380 "txt2bin.re"
			{ goto s_err; }
#line 1190 "txt2bin_s.cpp"
yy89:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy91;
			default:	goto yy88;
			}
yy90:
			yych = *++YYCURSOR;
			goto yy88;
yy91:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy93;
			default:	goto yy92;
			}
yy92:
			YYCURSOR = YYMARKER;
			goto yy88;
yy93:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy94;
			default:	goto yy92;
			}
yy94:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy95;
			default:	goto yy92;
			}
yy95:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy96;
			default:	goto yy92;
			}
yy96:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy97;
			default:	goto yy92;
			}
yy97:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy98;
			default:	goto yy92;
			}
yy98:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy99;
			default:	goto yy92;
			}
yy99:
			++YYCURSOR;
#line 379 "txt2bin.re"
			{ item.type = StartDependency;  goto s_5; }
#line 1249 "txt2bin_s.cpp"
yy101:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy102;
			default:	goto yy92;
			}
yy102:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy103;
			default:	goto yy92;
			}
yy103:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy104;
			default:	goto yy92;
			}
yy104:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy105;
			default:	goto yy92;
			}
yy105:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy106;
			default:	goto yy92;
			}
yy106:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy107;
			default:	goto yy92;
			}
yy107:
			++YYCURSOR;
#line 378 "txt2bin.re"
			{ item.type = Dependency;       goto s_5; }
#line 1290 "txt2bin_s.cpp"
yy109:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy110:
			switch (yych) {
			case '\t':
			case ' ':	goto yy109;
			default:	goto yy84;
			}
		}
#line 381 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_2:
	state=2;

	// printf("Entered s_2\n");

		s->tok = cursor;

#line 1313 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy113;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy115;
			default:	goto yy117;
			}
yy113:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy122;
yy114:
#line 391 "txt2bin.re"
			{ goto s_2; }
#line 1340 "txt2bin_s.cpp"
yy115:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy120;
yy116:
#line 392 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_10; }
#line 1348 "txt2bin_s.cpp"
yy117:
			++YYCURSOR;
#line 393 "txt2bin.re"
			{ goto s_err; }
#line 1353 "txt2bin_s.cpp"
yy119:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy120:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy119;
			default:	goto yy116;
			}
yy121:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy122:
			switch (yych) {
			case '\t':
			case ' ':	goto yy121;
			default:	goto yy114;
			}
		}
#line 394 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_3:
	state = 3;
	// printf("Entered s_3\n");

		s->tok = cursor;

#line 1394 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy125;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy127;
			default:	goto yy129;
			}
yy125:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy134;
yy126:
#line 404 "txt2bin.re"
			{ goto s_3; }
#line 1421 "txt2bin_s.cpp"
yy127:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy132;
yy128:
#line 405 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 1429 "txt2bin_s.cpp"
yy129:
			++YYCURSOR;
#line 406 "txt2bin.re"
			{ goto s_err; }
#line 1434 "txt2bin_s.cpp"
yy131:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy132:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy131;
			default:	goto yy128;
			}
yy133:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy134:
			switch (yych) {
			case '\t':
			case ' ':	goto yy133;
			default:	goto yy126;
			}
		}
#line 407 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_4:
	state = 4;
	// printf("Entered s_4\n");


#line 1474 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy137;
			case 'c':	goto yy139;
			case 'r':	goto yy142;
			case 's':	goto yy141;
			default:	goto yy143;
			}
yy137:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy158;
yy138:
#line 416 "txt2bin.re"
			{ goto s_4; }
#line 1494 "txt2bin_s.cpp"
yy139:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy153;
			default:	goto yy140;
			}
yy140:
#line 420 "txt2bin.re"
			{ goto s_err; }
#line 1504 "txt2bin_s.cpp"
yy141:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy149;
			default:	goto yy140;
			}
yy142:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy144;
			default:	goto yy140;
			}
yy143:
			yych = *++YYCURSOR;
			goto yy140;
yy144:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy146;
			default:	goto yy145;
			}
yy145:
			YYCURSOR = YYMARKER;
			goto yy140;
yy146:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy147;
			default:	goto yy145;
			}
yy147:
			++YYCURSOR;
#line 419 "txt2bin.re"
			{ item.type = RecvOp; goto s_2; }
#line 1539 "txt2bin_s.cpp"
yy149:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy150;
			default:	goto yy145;
			}
yy150:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy151;
			default:	goto yy145;
			}
yy151:
			++YYCURSOR;
#line 418 "txt2bin.re"
			{ item.type = SendOp; goto s_2; }
#line 1556 "txt2bin_s.cpp"
yy153:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy154;
			default:	goto yy145;
			}
yy154:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy155;
			default:	goto yy145;
			}
yy155:
			++YYCURSOR;
#line 417 "txt2bin.re"
			{ item.type = LoclOp; goto s_3; }
#line 1573 "txt2bin_s.cpp"
yy157:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy158:
			switch (yych) {
			case '\t':
			case ' ':	goto yy157;
			default:	goto yy138;
			}
		}
#line 421 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_5:
	state =5;
	// printf("Entered s_5\n");

		s->tok = cursor;

#line 1595 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy161;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy163;
			default:	goto yy165;
			}
yy161:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy170;
yy162:
#line 430 "txt2bin.re"
			{ goto s_5; }
#line 1664 "txt2bin_s.cpp"
yy163:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy168;
yy164:
#line 431 "txt2bin.re"
			{ item.label2 = add_label(s->tok, cursor); goto s_6; }
#line 1672 "txt2bin_s.cpp"
yy165:
			++YYCURSOR;
#line 432 "txt2bin.re"
			{ goto s_err; }
#line 1677 "txt2bin_s.cpp"
yy167:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy168:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy167;
			default:	goto yy164;
			}
yy169:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy170:
			switch (yych) {
			case '\t':
			case ' ':	goto yy169;
			default:	goto yy162;
			}
		}
#line 433 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_6:
	state = 6;
	// printf("Entered s_6\n");


#line 1770 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy173;
			case '\n':	goto yy177;
			case '\r':	goto yy175;
			default:	goto yy179;
			}
yy173:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy182;
yy174:
#line 442 "txt2bin.re"
			{ goto s_6; }
#line 1789 "txt2bin_s.cpp"
yy175:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy180;
			default:	goto yy176;
			}
yy176:
#line 444 "txt2bin.re"
			{ goto s_err; }
#line 1799 "txt2bin_s.cpp"
yy177:
			++YYCURSOR;
yy178:
#line 443 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1805 "txt2bin_s.cpp"
yy179:
			yych = *++YYCURSOR;
			goto yy176;
yy180:
			yych = *++YYCURSOR;
			goto yy178;
yy181:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy182:
			switch (yych) {
			case '\t':
			case ' ':	goto yy181;
			default:	goto yy174;
			}
		}
#line 445 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_7:
	state = 7;
	// printf("Entered s_7\n");


#line 1833 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy185;
			case '\n':	goto yy190;
			case '\r':	goto yy189;
			case 'c':	goto yy187;
			default:	goto yy192;
			}
yy185:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy199;
yy186:
#line 454 "txt2bin.re"
			{ goto s_7; }
#line 1853 "txt2bin_s.cpp"
yy187:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy194;
			default:	goto yy188;
			}
yy188:
#line 457 "txt2bin.re"
			{ goto s_err; }
#line 1863 "txt2bin_s.cpp"
yy189:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy193;
			default:	goto yy188;
			}
yy190:
			++YYCURSOR;
yy191:
#line 456 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1875 "txt2bin_s.cpp"
yy192:
			yych = *++YYCURSOR;
			goto yy188;
yy193:
			yych = *++YYCURSOR;
			goto yy191;
yy194:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy196;
			default:	goto yy195;
			}
yy195:
			YYCURSOR = YYMARKER;
			goto yy188;
yy196:
			++YYCURSOR;
#line 455 "txt2bin.re"
			{ goto s_8; }
#line 1895 "txt2bin_s.cpp"
yy198:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy199:
			switch (yych) {
			case '\t':
			case ' ':	goto yy198;
			default:	goto yy186;
			}
		}
#line 458 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_8:
	state =8;
	// printf("Entered s_8\n");

	s->tok = cursor;


#line 1919 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy202;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy204;
			default:	goto yy206;
			}
yy202:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy211;
yy203:
#line 469 "txt2bin.re"
			{ goto s_8; }
#line 1946 "txt2bin_s.cpp"
yy204:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy209;
yy205:
#line 470 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_9; }
#line 1954 "txt2bin_s.cpp"
yy206:
			++YYCURSOR;
#line 471 "txt2bin.re"
			{ goto s_err; }
#line 1959 "txt2bin_s.cpp"
yy208:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy209:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy208;
			default:	goto yy205;
			}
yy210:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy211:
			switch (yych) {
			case '\t':
			case ' ':	goto yy210;
			default:	goto yy203;
			}
		}
#line 472 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_9:
	state=9;
	// printf("Entered s_9\n");


#line 1999 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy214;
			case '\n':	goto yy218;
			case '\r':	goto yy216;
			default:	goto yy220;
			}
yy214:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy223;
yy215:
#line 481 "txt2bin.re"
			{ goto s_9; }
#line 2018 "txt2bin_s.cpp"
yy216:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy221;
			default:	goto yy217;
			}
yy217:
#line 483 "txt2bin.re"
			{ goto s_err; }
#line 2028 "txt2bin_s.cpp"
yy218:
			++YYCURSOR;
yy219:
#line 482 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2034 "txt2bin_s.cpp"
yy220:
			yych = *++YYCURSOR;
			goto yy217;
yy221:
			yych = *++YYCURSOR;
			goto yy219;
yy222:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy223:
			switch (yych) {
			case '\t':
			case ' ':	goto yy222;
			default:	goto yy215;
			}
		}
#line 484 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_10:
	state=10;
	// printf("Entered s_10\n");


#line 2062 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy226;
			case 'b':	goto yy228;
			default:	goto yy230;
			}
yy226:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy233;
yy227:
#line 493 "txt2bin.re"
			{ goto s_10; }
#line 2080 "txt2bin_s.cpp"
yy228:
			++YYCURSOR;
#line 494 "txt2bin.re"
			{ goto s_11; }
#line 2085 "txt2bin_s.cpp"
yy230:
			++YYCURSOR;
#line 495 "txt2bin.re"
			{ goto s_err; }
#line 2090 "txt2bin_s.cpp"
yy232:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy233:
			switch (yych) {
			case '\t':
			case ' ':	goto yy232;
			default:	goto yy227;
			}
		}
#line 496 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_11:
	state = 11;
	// printf("Entered s_11\n");


#line 2112 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy236;
			case 'f':	goto yy240;
			case 't':	goto yy238;
			default:	goto yy241;
			}
yy236:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy250;
yy237:
#line 505 "txt2bin.re"
			{ goto s_11; }
#line 2131 "txt2bin_s.cpp"
yy238:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 'o':	goto yy247;
			default:	goto yy239;
			}
yy239:
#line 508 "txt2bin.re"
			{ goto s_err; }
#line 2141 "txt2bin_s.cpp"
yy240:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy242;
			default:	goto yy239;
			}
yy241:
			yych = *++YYCURSOR;
			goto yy239;
yy242:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy244;
			default:	goto yy243;
			}
yy243:
			YYCURSOR = YYMARKER;
			goto yy239;
yy244:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy245;
			default:	goto yy243;
			}
yy245:
			++YYCURSOR;
#line 507 "txt2bin.re"
			{ if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp ) {goto s_12;} else {goto s_err;}; }
#line 2170 "txt2bin_s.cpp"
yy247:
			++YYCURSOR;
#line 506 "txt2bin.re"
			{ if (item.type == SendOp || item.type == PutOp || item.type == tPutOp ) {goto s_12;} else {goto s_err;}; }
#line 2175 "txt2bin_s.cpp"
yy249:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy250:
			switch (yych) {
			case '\t':
			case ' ':	goto yy249;
			default:	goto yy237;
			}
		}
#line 509 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_12:
	state = 12;
	// printf("Entered s_12\n");

	s->tok = cursor;


#line 2199 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy253;
			case '-':	goto yy255;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy257;
			default:	goto yy259;
			}
yy253:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy265;
yy254:
#line 520 "txt2bin.re"
			{ goto s_12; }
#line 2227 "txt2bin_s.cpp"
yy255:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '1':	goto yy262;
			default:	goto yy256;
			}
yy256:
#line 523 "txt2bin.re"
			{ goto s_err; }
#line 2237 "txt2bin_s.cpp"
yy257:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy261;
yy258:
#line 522 "txt2bin.re"
			{ item.target = add_number(s->tok, cursor); if (item.type==tGetOp || item.type == tPutOp) {goto s_25;} else {goto s_13;} }
#line 2245 "txt2bin_s.cpp"
yy259:
			yych = *++YYCURSOR;
			goto yy256;
yy260:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy261:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy260;
			default:	goto yy258;
			}
yy262:
			++YYCURSOR;
#line 521 "txt2bin.re"
			{if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp) {item.target = std::numeric_limits<uint32_t>::max(); if (item.type==tGetOp) {goto s_25;} else {goto s_13;}} else {goto s_err;}; }
#line 2271 "txt2bin_s.cpp"
yy264:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy265:
			switch (yych) {
			case '\t':
			case ' ':	goto yy264;
			default:	goto yy254;
			}
		}
#line 524 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_13:
	state = 13;
	// printf("Entered s_13\n");


#line 2293 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy268;
			case '\n':	goto yy275;
			case '\r':	goto yy274;
			case 'c':	goto yy272;
			case 'n':	goto yy273;
			case 't':	goto yy270;
			default:	goto yy277;
			}
yy268:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy290;
yy269:
#line 533 "txt2bin.re"
			{ goto s_13; }
#line 2315 "txt2bin_s.cpp"
yy270:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy286;
			default:	goto yy271;
			}
yy271:
#line 538 "txt2bin.re"
			{ goto s_err; }
#line 2325 "txt2bin_s.cpp"
yy272:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy283;
			default:	goto yy271;
			}
yy273:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy279;
			default:	goto yy271;
			}
yy274:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy278;
			default:	goto yy271;
			}
yy275:
			++YYCURSOR;
yy276:
#line 537 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2349 "txt2bin_s.cpp"
yy277:
			yych = *++YYCURSOR;
			goto yy271;
yy278:
			yych = *++YYCURSOR;
			goto yy276;
yy279:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy281;
			default:	goto yy280;
			}
yy280:
			YYCURSOR = YYMARKER;
			goto yy271;
yy281:
			++YYCURSOR;
#line 536 "txt2bin.re"
			{ goto s_18; }
#line 2369 "txt2bin_s.cpp"
yy283:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy284;
			default:	goto yy280;
			}
yy284:
			++YYCURSOR;
#line 535 "txt2bin.re"
			{ goto s_16; }
#line 2380 "txt2bin_s.cpp"
yy286:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy287;
			default:	goto yy280;
			}
yy287:
			++YYCURSOR;
#line 534 "txt2bin.re"
			{ goto s_14; }
#line 2391 "txt2bin_s.cpp"
yy289:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy290:
			switch (yych) {
			case '\t':
			case ' ':	goto yy289;
			default:	goto yy269;
			}
		}
#line 539 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_14:
	state = 14;
	// printf("Entered s_14\n");

	s->tok = cursor;


#line 2415 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy293;
			case '-':	goto yy295;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy297;
			default:	goto yy299;
			}
yy293:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy305;
yy294:
#line 550 "txt2bin.re"
			{ goto s_14; }
#line 2443 "txt2bin_s.cpp"
yy295:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '1':	goto yy302;
			default:	goto yy296;
			}
yy296:
#line 553 "txt2bin.re"
			{ goto s_err; }
#line 2453 "txt2bin_s.cpp"
yy297:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy301;
yy298:
#line 552 "txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_15; }
#line 2461 "txt2bin_s.cpp"
yy299:
			yych = *++YYCURSOR;
			goto yy296;
yy300:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy301:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy300;
			default:	goto yy298;
			}
yy302:
			++YYCURSOR;
#line 551 "txt2bin.re"
			{ item.tag = std::numeric_limits<uint32_t>::max(); goto s_15; }
#line 2487 "txt2bin_s.cpp"
yy304:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy305:
			switch (yych) {
			case '\t':
			case ' ':	goto yy304;
			default:	goto yy294;
			}
		}
#line 554 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_15:
	state =15;
	// printf("Entered s_15\n");


#line 2509 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy308;
			case '\n':	goto yy314;
			case '\r':	goto yy313;
			case 'c':	goto yy310;
			case 'n':	goto yy312;
			default:	goto yy316;
			}
yy308:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy326;
yy309:
#line 563 "txt2bin.re"
			{ goto s_15; }
#line 2530 "txt2bin_s.cpp"
yy310:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy322;
			default:	goto yy311;
			}
yy311:
#line 567 "txt2bin.re"
			{ goto s_err; }
#line 2540 "txt2bin_s.cpp"
yy312:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy318;
			default:	goto yy311;
			}
yy313:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy317;
			default:	goto yy311;
			}
yy314:
			++YYCURSOR;
yy315:
#line 566 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2558 "txt2bin_s.cpp"
yy316:
			yych = *++YYCURSOR;
			goto yy311;
yy317:
			yych = *++YYCURSOR;
			goto yy315;
yy318:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy320;
			default:	goto yy319;
			}
yy319:
			YYCURSOR = YYMARKER;
			goto yy311;
yy320:
			++YYCURSOR;
#line 565 "txt2bin.re"
			{ goto s_18; }
#line 2578 "txt2bin_s.cpp"
yy322:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy323;
			default:	goto yy319;
			}
yy323:
			++YYCURSOR;
#line 564 "txt2bin.re"
			{ goto s_16; }
#line 2589 "txt2bin_s.cpp"
yy325:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy326:
			switch (yych) {
			case '\t':
			case ' ':	goto yy325;
			default:	goto yy309;
			}
		}
#line 568 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_16:
	state = 16;
	// printf("Entered s_16\n");

	s->tok = cursor;


#line 2613 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy329;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy331;
			default:	goto yy333;
			}
yy329:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy338;
yy330:
#line 579 "txt2bin.re"
			{ goto s_16; }
#line 2640 "txt2bin_s.cpp"
yy331:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy336;
yy332:
#line 580 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_17; }
#line 2648 "txt2bin_s.cpp"
yy333:
			++YYCURSOR;
#line 581 "txt2bin.re"
			{ goto s_err; }
#line 2653 "txt2bin_s.cpp"
yy335:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy336:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy335;
			default:	goto yy332;
			}
yy337:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy338:
			switch (yych) {
			case '\t':
			case ' ':	goto yy337;
			default:	goto yy330;
			}
		}
#line 582 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_17:
	state = 17;
	// printf("Entered s_17\n");


#line 2693 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy341;
			case '\n':	goto yy346;
			case '\r':	goto yy345;
			case 'n':	goto yy343;
			default:	goto yy348;
			}
yy341:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy355;
yy342:
#line 591 "txt2bin.re"
			{ goto s_17; }
#line 2713 "txt2bin_s.cpp"
yy343:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy350;
			default:	goto yy344;
			}
yy344:
#line 594 "txt2bin.re"
			{ goto s_err; }
#line 2723 "txt2bin_s.cpp"
yy345:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy349;
			default:	goto yy344;
			}
yy346:
			++YYCURSOR;
yy347:
#line 593 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2735 "txt2bin_s.cpp"
yy348:
			yych = *++YYCURSOR;
			goto yy344;
yy349:
			yych = *++YYCURSOR;
			goto yy347;
yy350:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy352;
			default:	goto yy351;
			}
yy351:
			YYCURSOR = YYMARKER;
			goto yy344;
yy352:
			++YYCURSOR;
#line 592 "txt2bin.re"
			{ goto s_18; }
#line 2755 "txt2bin_s.cpp"
yy354:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy355:
			switch (yych) {
			case '\t':
			case ' ':	goto yy354;
			default:	goto yy342;
			}
		}
#line 595 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_18:
	state = 18;
	// printf("Entered s_18\n");

	s->tok = cursor;


#line 2779 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy358;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy360;
			default:	goto yy362;
			}
yy358:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy367;
yy359:
#line 606 "txt2bin.re"
			{ goto s_18; }
#line 2806 "txt2bin_s.cpp"
yy360:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy365;
yy361:
#line 607 "txt2bin.re"
			{ item.nic = add_number(s->tok, cursor); goto s_19; }
#line 2814 "txt2bin_s.cpp"
yy362:
			++YYCURSOR;
#line 608 "txt2bin.re"
			{ goto s_err; }
#line 2819 "txt2bin_s.cpp"
yy364:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy365:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy364;
			default:	goto yy361;
			}
yy366:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy367:
			switch (yych) {
			case '\t':
			case ' ':	goto yy366;
			default:	goto yy359;
			}
		}
#line 609 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_19:
	state = 19;
	// printf("Entered s_19\n");


#line 2859 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy370;
			case '\n':	goto yy374;
			case '\r':	goto yy372;
			default:	goto yy376;
			}
yy370:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy379;
yy371:
#line 618 "txt2bin.re"
			{ goto s_19; }
#line 2878 "txt2bin_s.cpp"
yy372:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy377;
			default:	goto yy373;
			}
yy373:
#line 620 "txt2bin.re"
			{ goto s_err; }
#line 2888 "txt2bin_s.cpp"
yy374:
			++YYCURSOR;
yy375:
#line 619 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2894 "txt2bin_s.cpp"
yy376:
			yych = *++YYCURSOR;
			goto yy373;
yy377:
			yych = *++YYCURSOR;
			goto yy375;
yy378:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy379:
			switch (yych) {
			case '\t':
			case ' ':	goto yy378;
			default:	goto yy371;
			}
		}
#line 621 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_20:
	state = 20;
	// printf("Entered s_20\n");

	s->tok = cursor;


#line 2924 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy382;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy384;
			default:	goto yy386;
			}
yy382:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy391;
yy383:
#line 632 "txt2bin.re"
			{ goto s_20; }
#line 2951 "txt2bin_s.cpp"
yy384:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy389;
yy385:
#line 633 "txt2bin.re"
			{ s->rank = add_number(s->tok, cursor); s->curr_rank = s->rank; goto s_21; }
#line 2959 "txt2bin_s.cpp"
yy386:
			++YYCURSOR;
#line 634 "txt2bin.re"
			{ goto s_err; }
#line 2964 "txt2bin_s.cpp"
yy388:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy389:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy388;
			default:	goto yy385;
			}
yy390:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy391:
			switch (yych) {
			case '\t':
			case ' ':	goto yy390;
			default:	goto yy383;
			}
		}
#line 635 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_21:
	state = 21;
	// printf("Entered s_21\n");


#line 3004 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy394;
			case '{':	goto yy396;
			default:	goto yy398;
			}
yy394:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy401;
yy395:
#line 644 "txt2bin.re"
			{ goto s_21; }
#line 3022 "txt2bin_s.cpp"
yy396:
			++YYCURSOR;
#line 645 "txt2bin.re"
			{ goto s_0; }
#line 3027 "txt2bin_s.cpp"
yy398:
			++YYCURSOR;
#line 646 "txt2bin.re"
			{ goto s_err; }
#line 3032 "txt2bin_s.cpp"
yy400:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy401:
			switch (yych) {
			case '\t':
			case ' ':	goto yy400;
			default:	goto yy395;
			}
		}
#line 647 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_22:
	state = 22;
	// printf("Entered s_22\n");

	s->tok = cursor;


#line 3056 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy404;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy406;
			default:	goto yy408;
			}
yy404:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy413;
yy405:
#line 658 "txt2bin.re"
			{ goto s_22; }
#line 3083 "txt2bin_s.cpp"
yy406:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy411;
yy407:
#line 659 "txt2bin.re"
			{ s->num_ranks = add_number(s->tok, cursor); goto s_0; }
#line 3091 "txt2bin_s.cpp"
yy408:
			++YYCURSOR;
#line 660 "txt2bin.re"
			{ goto s_err; }
#line 3096 "txt2bin_s.cpp"
yy410:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy411:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy410;
			default:	goto yy407;
			}
yy412:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy413:
			switch (yych) {
			case '\t':
			case ' ':	goto yy412;
			default:	goto yy405;
			}
		}
#line 661 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_23:
	state = 23;
	// printf("Entered s_23\n");


#line 3136 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy418;
			case '\r':	goto yy416;
			default:	goto yy420;
			}
yy416:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy421;
			default:	goto yy417;
			}
yy417:
#line 671 "txt2bin.re"
			{ goto s_23; }
#line 3155 "txt2bin_s.cpp"
yy418:
			++YYCURSOR;
yy419:
#line 670 "txt2bin.re"
			{ s->line++; continue;  }
#line 3161 "txt2bin_s.cpp"
yy420:
			yych = *++YYCURSOR;
			goto yy417;
yy421:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy419;
		}
#line 672 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_24:
	state = 24;
	// printf("Entered s_24\n");


#line 3180 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy427;
			case '\r':	goto yy426;
			case '*':	goto yy424;
			default:	goto yy429;
			}
yy424:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '/':	goto yy431;
			default:	goto yy425;
			}
yy425:
#line 683 "txt2bin.re"
			{ goto s_24; }
#line 3200 "txt2bin_s.cpp"
yy426:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy430;
			default:	goto yy425;
			}
yy427:
			++YYCURSOR;
yy428:
#line 682 "txt2bin.re"
			{ s->line++; goto s_24;  }
#line 3212 "txt2bin_s.cpp"
yy429:
			yych = *++YYCURSOR;
			goto yy425;
yy430:
			yych = *++YYCURSOR;
			goto yy428;
yy431:
			++YYCURSOR;
#line 681 "txt2bin.re"
			{ continue; }
#line 3223 "txt2bin_s.cpp"
		}
#line 684 "txt2bin.re"


	assert(0==1); //We should never reach this line

/* Begin triggered operation parameters */
s_25:
    state = 25;


#line 3235 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy435;
			case 'c':	goto yy437;
			default:	goto yy439;
			}
yy435:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy443;
yy436:
#line 693 "txt2bin.re"
			{ goto s_25; }
#line 3253 "txt2bin_s.cpp"
yy437:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 't':	goto yy440;
			default:	goto yy438;
			}
yy438:
#line 695 "txt2bin.re"
			{ goto s_err; }
#line 3263 "txt2bin_s.cpp"
yy439:
			yych = *++YYCURSOR;
			goto yy438;
yy440:
			++YYCURSOR;
#line 694 "txt2bin.re"
			{ goto s_26; }
#line 3271 "txt2bin_s.cpp"
yy442:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy443:
			switch (yych) {
			case '\t':
			case ' ':	goto yy442;
			default:	goto yy436;
			}
		}
#line 696 "txt2bin.re"


    assert(0==1);

s_26:
    state = 26;


#line 3292 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy446;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy448;
			default:	goto yy450;
			}
yy446:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy455;
yy447:
#line 704 "txt2bin.re"
			{ goto s_26; }
#line 3319 "txt2bin_s.cpp"
yy448:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy453;
yy449:
#line 705 "txt2bin.re"
			{ item->ct = add_number(s->tok, cursor); goto s_27; }
#line 3327 "txt2bin_s.cpp"
yy450:
			++YYCURSOR;
#line 706 "txt2bin.re"
			{ goto s_err; }
#line 3332 "txt2bin_s.cpp"
yy452:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy453:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy452;
			default:	goto yy449;
			}
yy454:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy455:
			switch (yych) {
			case '\t':
			case ' ':	goto yy454;
			default:	goto yy447;
			}
		}
#line 707 "txt2bin.re"


    assert(0==1);

s_27:
    state = 27;


#line 3371 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy458;
			case 't':	goto yy460;
			default:	goto yy462;
			}
yy458:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy474;
yy459:
#line 715 "txt2bin.re"
			{ goto s_27; }
#line 3389 "txt2bin_s.cpp"
yy460:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'h':	goto yy463;
			default:	goto yy461;
			}
yy461:
#line 717 "txt2bin.re"
			{ goto s_err; }
#line 3399 "txt2bin_s.cpp"
yy462:
			yych = *++YYCURSOR;
			goto yy461;
yy463:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy465;
			default:	goto yy464;
			}
yy464:
			YYCURSOR = YYMARKER;
			goto yy461;
yy465:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy466;
			default:	goto yy464;
			}
yy466:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy467;
			default:	goto yy464;
			}
yy467:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy468;
			default:	goto yy464;
			}
yy468:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy469;
			default:	goto yy464;
			}
yy469:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy470;
			default:	goto yy464;
			}
yy470:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy471;
			default:	goto yy464;
			}
yy471:
			++YYCURSOR;
#line 716 "txt2bin.re"
			{ goto s_28; }
#line 3452 "txt2bin_s.cpp"
yy473:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy474:
			switch (yych) {
			case '\t':
			case ' ':	goto yy473;
			default:	goto yy459;
			}
		}
#line 718 "txt2bin.re"


    assert(0==1);

s_28:
    state = 28;


#line 3473 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy477;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy479;
			default:	goto yy481;
			}
yy477:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy486;
yy478:
#line 726 "txt2bin.re"
			{ goto s_28; }
#line 3500 "txt2bin_s.cpp"
yy479:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy484;
yy480:
#line 727 "txt2bin.re"
			{ item->threshold = add_number(s->top, cursor); if (item->type==tAppendOp) {goto s_34;} else {goto s_13;} }
#line 3508 "txt2bin_s.cpp"
yy481:
			++YYCURSOR;
#line 728 "txt2bin.re"
			{ goto s_err; }
#line 3513 "txt2bin_s.cpp"
yy483:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy484:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy483;
			default:	goto yy480;
			}
yy485:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy486:
			switch (yych) {
			case '\t':
			case ' ':	goto yy485;
			default:	goto yy478;
			}
		}
#line 729 "txt2bin.re"


    assert(0==1);
/* End triggered ooeration parameters */

/* Begin Append/tAppend */
s_29:
    state=29;


#line 3554 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy489;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy491;
			default:	goto yy493;
			}
yy489:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy498;
yy490:
#line 739 "txt2bin.re"
			{ goto s_29; }
#line 3581 "txt2bin_s.cpp"
yy491:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy496;
yy492:
#line 740 "txt2bin.re"
			{ item->size = add_number(s->top, cursor); goto s_38; }
#line 3589 "txt2bin_s.cpp"
yy493:
			++YYCURSOR;
#line 741 "txt2bin.re"
			{ goto s_err; }
#line 3594 "txt2bin_s.cpp"
yy495:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy496:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy495;
			default:	goto yy492;
			}
yy497:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy498:
			switch (yych) {
			case '\t':
			case ' ':	goto yy497;
			default:	goto yy490;
			}
		}
#line 742 "txt2bin.re"



s_30:
    state=30;


#line 3632 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy501;
			case 't':	goto yy503;
			default:	goto yy505;
			}
yy501:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy509;
yy502:
#line 749 "txt2bin.re"
			{ goto s_30; }
#line 3650 "txt2bin_s.cpp"
yy503:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 'o':	goto yy506;
			default:	goto yy504;
			}
yy504:
#line 751 "txt2bin.re"
			{ goto s_err; }
#line 3660 "txt2bin_s.cpp"
yy505:
			yych = *++YYCURSOR;
			goto yy504;
yy506:
			++YYCURSOR;
#line 750 "txt2bin.re"
			{ goto s_31; }
#line 3668 "txt2bin_s.cpp"
yy508:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy509:
			switch (yych) {
			case '\t':
			case ' ':	goto yy508;
			default:	goto yy502;
			}
		}
#line 752 "txt2bin.re"


s_31:
    state=31;

#line 3686 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy512;
			case 'o':	goto yy514;
			case 'p':	goto yy516;
			default:	goto yy517;
			}
yy512:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy546;
yy513:
#line 757 "txt2bin.re"
			{ goto s_31; }
#line 3705 "txt2bin_s.cpp"
yy514:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'v':	goto yy532;
			default:	goto yy515;
			}
yy515:
#line 760 "txt2bin.re"
			{ goto s_err; }
#line 3715 "txt2bin_s.cpp"
yy516:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy518;
			default:	goto yy515;
			}
yy517:
			yych = *++YYCURSOR;
			goto yy515;
yy518:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy520;
			default:	goto yy519;
			}
yy519:
			YYCURSOR = YYMARKER;
			goto yy515;
yy520:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy521;
			default:	goto yy519;
			}
yy521:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy522;
			default:	goto yy519;
			}
yy522:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy523;
			default:	goto yy519;
			}
yy523:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy524;
			default:	goto yy519;
			}
yy524:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'y':	goto yy525;
			default:	goto yy519;
			}
yy525:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy526;
			default:	goto yy519;
			}
yy526:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy527;
			default:	goto yy519;
			}
yy527:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy528;
			default:	goto yy519;
			}
yy528:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy529;
			default:	goto yy519;
			}
yy529:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy530;
			default:	goto yy519;
			}
yy530:
			++YYCURSOR;
#line 759 "txt2bin.re"
			{ item->options |= OPT_PRIORITY_LIST; goto s_32; }
#line 3798 "txt2bin_s.cpp"
yy532:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy533;
			default:	goto yy519;
			}
yy533:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy534;
			default:	goto yy519;
			}
yy534:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'f':	goto yy535;
			default:	goto yy519;
			}
yy535:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy536;
			default:	goto yy519;
			}
yy536:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy537;
			default:	goto yy519;
			}
yy537:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy538;
			default:	goto yy519;
			}
yy538:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy539;
			default:	goto yy519;
			}
yy539:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy540;
			default:	goto yy519;
			}
yy540:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy541;
			default:	goto yy519;
			}
yy541:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy542;
			default:	goto yy519;
			}
yy542:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy543;
			default:	goto yy519;
			}
yy543:
			++YYCURSOR;
#line 758 "txt2bin.re"
			{ item->options |= OPT_OVERFLOW_LIST; goto s_32; }
#line 3869 "txt2bin_s.cpp"
yy545:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy546:
			switch (yych) {
			case '\t':
			case ' ':	goto yy545;
			default:	goto yy513;
			}
		}
#line 761 "txt2bin.re"


s_32:
    state=32;

#line 3887 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy549;
			case 'a':	goto yy551;
			default:	goto yy553;
			}
yy549:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy563;
yy550:
#line 766 "txt2bin.re"
			{ goto s_32; }
#line 3905 "txt2bin_s.cpp"
yy551:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'l':	goto yy554;
			default:	goto yy552;
			}
yy552:
#line 768 "txt2bin.re"
			{ goto s_err; }
#line 3915 "txt2bin_s.cpp"
yy553:
			yych = *++YYCURSOR;
			goto yy552;
yy554:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy556;
			default:	goto yy555;
			}
yy555:
			YYCURSOR = YYMARKER;
			goto yy552;
yy556:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy557;
			default:	goto yy555;
			}
yy557:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy558;
			default:	goto yy555;
			}
yy558:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy559;
			default:	goto yy555;
			}
yy559:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy560;
			default:	goto yy555;
			}
yy560:
			++YYCURSOR;
#line 767 "txt2bin.re"
			{ goto s_33; }
#line 3956 "txt2bin_s.cpp"
yy562:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy563:
			switch (yych) {
			case '\t':
			case ' ':	goto yy562;
			default:	goto yy550;
			}
		}
#line 769 "txt2bin.re"


s_33:
    state=33;


#line 3975 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy566;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy568;
			default:	goto yy570;
			}
yy566:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy575;
yy567:
#line 775 "txt2bin.re"
			{ goto s_33; }
#line 4002 "txt2bin_s.cpp"
yy568:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy573;
yy569:
#line 776 "txt2bin.re"
			{ item->target = add_number(s->tok, cursor); if (item->type == tAppendOp)  { goto s_25; } else {goto s_34;} }
#line 4010 "txt2bin_s.cpp"
yy570:
			++YYCURSOR;
#line 777 "txt2bin.re"
			{ goto s_err; }
#line 4015 "txt2bin_s.cpp"
yy572:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy573:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy572;
			default:	goto yy569;
			}
yy574:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy575:
			switch (yych) {
			case '\t':
			case ' ':	goto yy574;
			default:	goto yy567;
			}
		}
#line 778 "txt2bin.re"


s_34:
    state=34;


#line 4052 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy578;
			case '\n':	goto yy586;
			case '\r':	goto yy585;
			case 'c':	goto yy583;
			case 'n':	goto yy584;
			case 't':	goto yy582;
			case 'u':	goto yy580;
			default:	goto yy588;
			}
yy578:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy609;
yy579:
#line 784 "txt2bin.re"
			{ goto s_34; }
#line 4075 "txt2bin_s.cpp"
yy580:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 's':	goto yy600;
			default:	goto yy581;
			}
yy581:
#line 790 "txt2bin.re"
			{ goto s_err; }
#line 4085 "txt2bin_s.cpp"
yy582:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy597;
			default:	goto yy581;
			}
yy583:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy594;
			default:	goto yy581;
			}
yy584:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy590;
			default:	goto yy581;
			}
yy585:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy589;
			default:	goto yy581;
			}
yy586:
			++YYCURSOR;
yy587:
#line 789 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 4115 "txt2bin_s.cpp"
yy588:
			yych = *++YYCURSOR;
			goto yy581;
yy589:
			yych = *++YYCURSOR;
			goto yy587;
yy590:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy592;
			default:	goto yy591;
			}
yy591:
			YYCURSOR = YYMARKER;
			goto yy581;
yy592:
			++YYCURSOR;
#line 788 "txt2bin.re"
			{ goto s_18; }
#line 4135 "txt2bin_s.cpp"
yy594:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy595;
			default:	goto yy591;
			}
yy595:
			++YYCURSOR;
#line 787 "txt2bin.re"
			{ goto s_16; }
#line 4146 "txt2bin_s.cpp"
yy597:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy598;
			default:	goto yy591;
			}
yy598:
			++YYCURSOR;
#line 786 "txt2bin.re"
			{ goto s_14; }
#line 4157 "txt2bin_s.cpp"
yy600:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy601;
			default:	goto yy591;
			}
yy601:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy602;
			default:	goto yy591;
			}
yy602:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy603;
			default:	goto yy591;
			}
yy603:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy604;
			default:	goto yy591;
			}
yy604:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy605;
			default:	goto yy591;
			}
yy605:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy606;
			default:	goto yy591;
			}
yy606:
			++YYCURSOR;
#line 785 "txt2bin.re"
			{ item->options |= OPT_USE_ONCE; goto s_13; }
#line 4198 "txt2bin_s.cpp"
yy608:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy609:
			switch (yych) {
			case '\t':
			case ' ':	goto yy608;
			default:	goto yy579;
			}
		}
#line 791 "txt2bin.re"

/* End Append/tAppend */

/* Begin CTWait */
s_35:
    state=35;


#line 4219 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy612;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy614;
			default:	goto yy616;
			}
yy612:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy621;
yy613:
#line 799 "txt2bin.re"
			{ goto s_35; }
#line 4246 "txt2bin_s.cpp"
yy614:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy619;
yy615:
#line 800 "txt2bin.re"
			{ item->ct = add_number(s->tok, cursor); goto s_36; }
#line 4254 "txt2bin_s.cpp"
yy616:
			++YYCURSOR;
#line 801 "txt2bin.re"
			{ goto s_err; }
#line 4259 "txt2bin_s.cpp"
yy618:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy619:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy618;
			default:	goto yy615;
			}
yy620:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy621:
			switch (yych) {
			case '\t':
			case ' ':	goto yy620;
			default:	goto yy613;
			}
		}
#line 802 "txt2bin.re"


s_36:
    state=36;


#line 4296 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy624;
			case 'f':	goto yy626;
			default:	goto yy628;
			}
yy624:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy634;
yy625:
#line 808 "txt2bin.re"
			{ goto s_36; }
#line 4314 "txt2bin_s.cpp"
yy626:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'o':	goto yy629;
			default:	goto yy627;
			}
yy627:
#line 810 "txt2bin.re"
			{ goto s_err; }
#line 4324 "txt2bin_s.cpp"
yy628:
			yych = *++YYCURSOR;
			goto yy627;
yy629:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy631;
			default:	goto yy630;
			}
yy630:
			YYCURSOR = YYMARKER;
			goto yy627;
yy631:
			++YYCURSOR;
#line 809 "txt2bin.re"
			{ goto s_37; }
#line 4341 "txt2bin_s.cpp"
yy633:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy634:
			switch (yych) {
			case '\t':
			case ' ':	goto yy633;
			default:	goto yy625;
			}
		}
#line 811 "txt2bin.re"


s_37:
    state=37;


#line 4360 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy637;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy639;
			default:	goto yy641;
			}
yy637:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy646;
yy638:
#line 817 "txt2bin.re"
			{ goto s_37; }
#line 4387 "txt2bin_s.cpp"
yy639:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy644;
yy640:
#line 818 "txt2bin.re"
			{ item->size = add_number(s->tok, cursor); goto s_7; }
#line 4395 "txt2bin_s.cpp"
yy641:
			++YYCURSOR;
#line 819 "txt2bin.re"
			{ goto s_err; }
#line 4400 "txt2bin_s.cpp"
yy643:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy644:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy643;
			default:	goto yy640;
			}
yy645:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy646:
			switch (yych) {
			case '\t':
			case ' ':	goto yy645;
			default:	goto yy638;
			}
		}
#line 820 "txt2bin.re"


/* End CTWait */

//I forgot it in the append...
s_38:
	state=38;
	// printf("Entered s_10\n");


#line 4441 "txt2bin_s.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy649;
			case 'b':	goto yy651;
			default:	goto yy653;
			}
yy649:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy656;
yy650:
#line 830 "txt2bin.re"
			{ goto s_38; }
#line 4459 "txt2bin_s.cpp"
yy651:
			++YYCURSOR;
#line 831 "txt2bin.re"
			{ goto s_30; }
#line 4464 "txt2bin_s.cpp"
yy653:
			++YYCURSOR;
#line 832 "txt2bin.re"
			{ goto s_err; }
#line 4469 "txt2bin_s.cpp"
yy655:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy656:
			switch (yych) {
			case '\t':
			case ' ':	goto yy655;
			default:	goto yy650;
			}
		}
#line 833 "txt2bin.re"



s_err:

	fprintf(stderr, "Error in line %i:\n", s->line);

	uchar* nlbef = s->bot;
	uchar* nlaft = s->lim;
	// find the last newline before the error
	uchar* c = cursor-2;
	while (c>s->bot) {
		c--;
		if (*c == '\n') {
			nlbef = c;
			break;
		}
	}
	// find the next newline after the error
	c = cursor-2;
	while (c<s->lim) {
		c++;
		if (*c == '\n') {
			nlaft = c;
			break;
		}
	}

	for (uchar* c = nlbef+1; c<nlaft; c++) {
		fprintf(stderr, "%c", *c);
	}
	fprintf(stderr, "\n");

	for (int cnt=0; cnt<(cursor-2)-nlbef; cnt++) {
		fprintf(stderr, " ");
	}
	fprintf(stderr, "^\n");


	switch(state) {
		case 0:
			fprintf(stderr,"Expected: \"rank\", \"num_ranks\", \"calc\", \"send\", \"recv\", an identifier, \"}\" or \"\\n\"\n");
			break;
		case 1:
			fprintf(stderr,"Expected: \":\", \"requires\" or \"irequires\"\n");
			break;
		case 2:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 3:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 4:
			fprintf(stderr,"Expected: \"calc\", \"send\" or \"recv\"\n");
			break;
		case 5:
			fprintf(stderr,"Expected: an identifier\n");
			break;
		case 6:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 7:
			fprintf(stderr,"Expected: \"cpu\" or \"\\n\"\n");
			break;
		case 8:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 9:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 10:
			fprintf(stderr,"Expected: \"b\"\n");
			break;
		case 11:
			if (item.type == SendOp) fprintf(stderr,"Expected: \"to\"\n");
			else if (item.type == RecvOp) fprintf(stderr,"Expected: \"from\"\n");
			else fprintf(stderr,"Expected: \"to\" or \"from\"\n");
			break;
		case 12:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 13:
			fprintf(stderr,"Expected: \"tag\", \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 14:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 15:
			fprintf(stderr,"Expected: \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 16:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 17:
			fprintf(stderr,"Expected: \"nic\" or \"\\n\"\n");
			break;
		case 18:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 19:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 20:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 21:
			fprintf(stderr,"Expected: \"{\"\n");
			break;
		case 22:
			fprintf(stderr,"Expected: an integer\n");
			break;
	}

	if (*(cursor-1) == '\n') {
		fprintf(stderr, "Instead the schedule contained: \"\\n\"\n");
	}
	else {
		fprintf(stderr, "Instead the schedule contained: \"%c\"\n", *(cursor-1));
	}



	exit(EXIT_FAILURE);

}
}

main(int argc, char **argv){

	Scanner in;
	int lastprogress = 0;

	if (cmdline_parser(argc, argv, &args_info) != 0) {
		fprintf(stderr, "Couldn't parse command line arguments!\n");
		exit(EXIT_FAILURE);
	}

    memset((char*) &in, 0, sizeof(in));
   	in.fd = fopen(args_info.input_arg, "r");
	if (in.fd == NULL) {
		fprintf(stderr, "Couldn't open input file %s!\n", args_info.input_arg);
		exit(EXIT_FAILURE);
	}
	in.idtbl = new std::map<std::string, goalop_t>;

	uint32_t numranks = -1;

	while (true) {

		in.schedule = new Goal;

		scan(&in);

		if (in.num_ranks < 1) {
			fprintf(stderr, "Parse error: Number of Ranks undefined\n");
			exit(EXIT_FAILURE);
		}

		in.idtbl->clear();

		in.schedule->SetRank(in.curr_rank);
		in.schedule->SetNumRanks(in.num_ranks);
		in.schedule->SerializeSchedule(args_info.output_arg);
		delete in.schedule;
		int newprogress = round((((double) in.curr_rank) / in.num_ranks)*100);
		if (args_info.progress_given && (newprogress > lastprogress) ) {
			lastprogress = newprogress;
			printf("Progress %i%% - parsed schedule %i/%i\n", lastprogress, in.curr_rank, in.num_ranks);
		}
		if (in.curr_rank+1 == in.num_ranks) break;
	}

	free(in.bot);
	exit(EXIT_SUCCESS);
}
