/* Generated by re2c 0.16 on Tue Feb 20 00:32:15 2018 */
#line 1 "txt2bin.re"
#include <map>
#include <math.h>
#include <string>
#include <limits>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>

#include "Goal.hpp"
#include "cmdline_txt2bin.h"

typedef unsigned int uint;
typedef unsigned char uchar;

#define	BSIZE	10240

#define	YYCTYPE		uchar
#define	YYCURSOR	cursor
#define	YYLIMIT		s->lim
#define	YYMARKER	s->ptr
#define	YYFILL(n)	{cursor = fill(s, cursor, n);}


#define OPT_USE_ONCE 1
#define OPT_OVERFLOW_LIST 2
#define OPT_PRIORITY_LIST 4


#define	RET(i)	{s->cur = cursor; return i;}

gengetopt_args_info args_info;

typedef struct Scanner {
    FILE*		fd;
    uchar		*bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint		line;
	int			rank;
	uint32_t 	curr_rank, num_ranks;
	Goal*		schedule;
	std::map<std::string, goalop_t>* idtbl;
} Scanner;

typedef struct Item {
	char type;
	char *label1;
	char *label2;
	uint64_t size;
	uint32_t target;
	uint32_t tag;
	uint8_t cpu;
	uint8_t nic;
	char options;
	uint32_t oct; //my ct
	uint32_t ct; //triggering ct
	uint64_t threshold;
} Item;

enum OpTypes {
	Undefined,
	SendOp,
	RecvOp,
	LoclOp,
	StartDependency,
	Dependency,
	AppendOp,
	PutOp,
	GetOp,
	CTWaitOp,
	tAppendOp,
	tPutOp,
	tGetOp
};

inline uint64_t add_number(unsigned char *s, unsigned char *e) {

	uint64_t num = 0;
	--s;
	while(++s < e) num = num * 10 + (*s - '0');

	return num;
}

inline void insert_id(Scanner *s, char *id, goalop_t op) {

	s->idtbl->insert(std::make_pair(std::string(id), op));
	free(id);
}

inline goalop_t retrieve_id(Scanner *s, char *id) {

	std::map<std::string, goalop_t>::iterator it;
	it = s->idtbl->find(std::string(id));
	if (it == s->idtbl->end()) {
		fprintf(stderr, "A dependency references label %s, which is undefined!\n", id);
		exit(EXIT_FAILURE);
	}
	free(id);
	return it->second;
}

void process_item(Scanner *s, Item *item) {

/*
	printf("Parsed Item:\n");
	printf("  Type: ");
	if (item->type == Undefined) printf("Undefined\n");
	if (item->type == SendOp) printf("Send\n");
	if (item->type == RecvOp) printf("Recv\n");
	if (item->type == LoclOp) printf("LoclOp\n");
	if (item->type == StartDependency) printf("IRequires\n");
	if (item->type == Dependency) printf("Requires\n");
	printf("  Label1: %s\n", item->label1);
	printf("  Label2: %s\n", item->label2);
	printf("  Size: %i\n", item->size);
	printf("  Target: %i\n", item->target);
	printf("  Tag: %i\n", item->tag);
	printf("  CPU: %i\n", item->cpu);
	printf("  NIC: %i\n", item->nic);
*/

	goalop_t op, op2;

	switch (item->type) {
		case Undefined:
			fprintf(stderr, "Error while parsing, attempt to add a undefined operation\n");
			exit(EXIT_FAILURE);
			break;
		case SendOp:
			op = s->schedule->Send(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case RecvOp:
			op = s->schedule->Recv(item->target, s->rank, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case LoclOp:
			op = s->schedule->Calc(s->rank, item->size, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
        case PutOp:
            op = s->schedule->Put(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case GetOp:
            op = s->schedule->Get(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case AppendOp:
            op = s->schedule->Append(s->rank, item->oct, item->target, item->size, item->tag, item->options, item->cpu, item->nic);

            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case CTWaitOp:
            op = s->schedule->CTWait(s->rank, item->ct, item->size, item->cpu);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tAppendOp:
            op = s->schedule->tAppend(s->rank, item->oct, item->target, item->size, item->tag, item->options, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tPutOp:
            op = s->schedule->tPut(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tGetOp:
            op = s->schedule->tGet(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
		case StartDependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->StartDependency(op, op2);
			break;
		case Dependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->Dependency(op, op2);
			break;
		default:
			break;
	}
}

inline char* add_label(unsigned char *s, unsigned char *e) {

	char *buf = NULL;

	buf = (char *) malloc((e-s)+1);
	memcpy((void *) buf, (void *) s, (size_t) (e-s));
	buf[e-s] = '\0';

	return buf;

}


uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	if(!s->eof) {
		uint cnt = s->tok - s->bot;
		if(cnt){
			if ((s->lim - s->tok) < abs(s->bot - s->tok)) memcpy(s->bot, s->tok, s->lim - s->tok);
			else memmove(s->bot, s->tok, s->lim - s->tok);
			s->tok = s->bot;
			s->ptr -= cnt;
			cursor -= cnt;
			s->pos -= cnt;
			s->lim -= cnt;
		}
		if((s->top - s->lim) < BSIZE){
			uchar *buf = (uchar*) malloc(((s->lim - s->bot) + BSIZE)*sizeof(uchar));
			if ((s->lim - s->tok) > abs(s->tok - buf)) memmove(buf, s->tok, s->lim - s->tok);
			else memcpy(buf, s->tok, s->lim - s->tok);
			s->tok = buf;
			s->ptr = &buf[s->ptr - s->bot];
			cursor = &buf[cursor - s->bot];
			s->pos = &buf[s->pos - s->bot];
			s->lim = &buf[s->lim - s->bot];
			s->top = &s->lim[BSIZE];
			free(s->bot);
			s->bot = buf;
		}
		cnt = fread((char*) s->lim, 1, BSIZE, s->fd);
		if(cnt != BSIZE) {
			s->eof = &s->lim[cnt];
			*(s->eof)++ = '\n';
		}
		s->lim += cnt;
		//assert(cnt >= numtoread);
	}
	return cursor;
}

/*
uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	static bool firstcall = true;

	if (firstcall) {

		void *buf;
		struct stat statbuf;

		int ret = fstat(fileno(s->fd), &statbuf);
		buf = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fileno(s->fd), 0);
		assert(buf != NULL);
		s->lim = (uchar*) buf;
		s->lim += statbuf.st_size;
		s->eof = s->lim;
		return (uchar*) buf;
	}
	else {
		assert(0==1);
	}
}
*/

int scan(Scanner *s) {

	//uchar *cursor = s->cur;

	static uchar *cursor = NULL;
	Item item;
	int state;

	for (;;) {

s_0:

	if ((cursor == s->eof) and (cursor != NULL)) {
		fprintf(stderr, "Reached the end of the inputfile - did you forget a closing bracket?\n");
		return s->rank;
	}

	s->tok = cursor;
	state = 0;

	// printf("Entered s_0\n");
	// if (((s->line % 100) == 0) or (s->line < 100)) printf("Line: %i\n", s->line);

	item.type = Undefined;
	item.label1 = NULL;
	item.label2 = NULL;
	item.cpu = 0;
	item.nic = 0;
	item.tag = 0;
	item.options = 0;
	item.ct = 0;
	item.threshold = 0;
	item.oct = 0;


#line 306 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			case '\n':	goto yy7;
			case '\r':	goto yy9;
			case '/':	goto yy10;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'p':
			case 'q':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			case 'c':	goto yy14;
			case 'n':	goto yy15;
			case 'r':	goto yy16;
			case 's':	goto yy17;
			case '}':	goto yy18;
			default:	goto yy2;
			}
yy2:
			++YYCURSOR;
yy3:
#line 370 "txt2bin.re"
			{ goto s_err; }
#line 377 "txt2bin.cpp"
yy4:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			default:	goto yy6;
			}
yy6:
#line 349 "txt2bin.re"
			{ s->tok = cursor; }
#line 390 "txt2bin.cpp"
yy7:
			++YYCURSOR;
#line 368 "txt2bin.re"
			{ s->line++; continue; }
#line 395 "txt2bin.cpp"
yy9:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy7;
			default:	goto yy3;
			}
yy10:
			yych = *++YYCURSOR;
			switch (yych) {
			case '*':	goto yy20;
			case '/':	goto yy22;
			default:	goto yy3;
			}
yy11:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy12:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy13;
			}
yy13:
#line 355 "txt2bin.re"
			{ item.label1 = add_label(s->tok, cursor); goto s_1; }
#line 483 "txt2bin.cpp"
yy14:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy24;
			default:	goto yy12;
			}
yy15:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy25;
			default:	goto yy12;
			}
yy16:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy26;
			case 'e':	goto yy27;
			default:	goto yy12;
			}
yy17:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy28;
			default:	goto yy12;
			}
yy18:
			++YYCURSOR;
#line 369 "txt2bin.re"
			{ if (s->rank == -1) goto s_err; int oldrank = s->rank; s->rank = -1; return oldrank; }
#line 513 "txt2bin.cpp"
yy20:
			++YYCURSOR;
#line 357 "txt2bin.re"
			{ goto s_24; }
#line 518 "txt2bin.cpp"
yy22:
			++YYCURSOR;
#line 356 "txt2bin.re"
			{ goto s_23; }
#line 523 "txt2bin.cpp"
yy24:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy29;
			default:	goto yy12;
			}
yy25:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy30;
			default:	goto yy12;
			}
yy26:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy31;
			default:	goto yy12;
			}
yy27:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy32;
			default:	goto yy12;
			}
yy28:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy33;
			default:	goto yy12;
			}
yy29:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy34;
			default:	goto yy12;
			}
yy30:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy36;
			default:	goto yy12;
			}
yy31:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy37;
			default:	goto yy12;
			}
yy32:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy39;
			default:	goto yy12;
			}
yy33:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy41;
			default:	goto yy12;
			}
yy34:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy35;
			}
yy35:
#line 352 "txt2bin.re"
			{ item.type = LoclOp;  goto s_3; }
#line 655 "txt2bin.cpp"
yy36:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy43;
			default:	goto yy12;
			}
yy37:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy38;
			}
yy38:
#line 353 "txt2bin.re"
			{ goto s_20; }
#line 733 "txt2bin.cpp"
yy39:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy40;
			}
yy40:
#line 351 "txt2bin.re"
			{ item.type = RecvOp;  goto s_2; }
#line 805 "txt2bin.cpp"
yy41:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy42;
			}
yy42:
#line 350 "txt2bin.re"
			{ item.type = SendOp;  goto s_2; }
#line 877 "txt2bin.cpp"
yy43:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy44;
			default:	goto yy12;
			}
yy44:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy45;
			default:	goto yy12;
			}
yy45:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy46;
			default:	goto yy12;
			}
yy46:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy47;
			default:	goto yy12;
			}
yy47:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy48;
			}
yy48:
#line 354 "txt2bin.re"
			{ goto s_22; }
#line 973 "txt2bin.cpp"
		}
#line 371 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_1:
	state =1;

	// printf("Entered s_1\n");


#line 986 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy53;
			case ':':	goto yy56;
			case 'i':	goto yy58;
			case 'r':	goto yy59;
			default:	goto yy51;
			}
yy51:
			++YYCURSOR;
yy52:
#line 385 "txt2bin.re"
			{ goto s_err; }
#line 1004 "txt2bin.cpp"
yy53:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy53;
			default:	goto yy55;
			}
yy55:
#line 381 "txt2bin.re"
			{ goto s_1; }
#line 1017 "txt2bin.cpp"
yy56:
			++YYCURSOR;
#line 382 "txt2bin.re"
			{ goto s_4; }
#line 1022 "txt2bin.cpp"
yy58:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy60;
			default:	goto yy52;
			}
yy59:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy62;
			default:	goto yy52;
			}
yy60:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy63;
			default:	goto yy61;
			}
yy61:
			YYCURSOR = YYMARKER;
			goto yy52;
yy62:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy64;
			default:	goto yy61;
			}
yy63:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy65;
			default:	goto yy61;
			}
yy64:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy66;
			default:	goto yy61;
			}
yy65:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy67;
			default:	goto yy61;
			}
yy66:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy68;
			default:	goto yy61;
			}
yy67:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy69;
			default:	goto yy61;
			}
yy68:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy70;
			default:	goto yy61;
			}
yy69:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy71;
			default:	goto yy61;
			}
yy70:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy72;
			default:	goto yy61;
			}
yy71:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy73;
			default:	goto yy61;
			}
yy72:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy74;
			default:	goto yy61;
			}
yy73:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy76;
			default:	goto yy61;
			}
yy74:
			++YYCURSOR;
#line 383 "txt2bin.re"
			{ item.type = Dependency;       goto s_5; }
#line 1120 "txt2bin.cpp"
yy76:
			++YYCURSOR;
#line 384 "txt2bin.re"
			{ item.type = StartDependency;  goto s_5; }
#line 1125 "txt2bin.cpp"
		}
#line 386 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_2:
	state=2;

	// printf("Entered s_2\n");

		s->tok = cursor;

#line 1138 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy82;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy85;
			default:	goto yy80;
			}
yy80:
			++YYCURSOR;
#line 398 "txt2bin.re"
			{ goto s_err; }
#line 1162 "txt2bin.cpp"
yy82:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy82;
			default:	goto yy84;
			}
yy84:
#line 396 "txt2bin.re"
			{ goto s_2; }
#line 1175 "txt2bin.cpp"
yy85:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy85;
			default:	goto yy87;
			}
yy87:
#line 397 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_10; }
#line 1196 "txt2bin.cpp"
		}
#line 399 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_3:
	state = 3;
	// printf("Entered s_3\n");

		s->tok = cursor;

#line 1209 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy92;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy95;
			default:	goto yy90;
			}
yy90:
			++YYCURSOR;
#line 411 "txt2bin.re"
			{ goto s_err; }
#line 1233 "txt2bin.cpp"
yy92:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy92;
			default:	goto yy94;
			}
yy94:
#line 409 "txt2bin.re"
			{ goto s_3; }
#line 1246 "txt2bin.cpp"
yy95:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy95;
			default:	goto yy97;
			}
yy97:
#line 410 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 1267 "txt2bin.cpp"
		}
#line 412 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_4:
	state = 4;
	// printf("Entered s_4\n");


#line 1279 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy102;
			case 'a':	goto yy105;
			case 'c':	goto yy106;
			case 'g':	goto yy107;
			case 'p':	goto yy108;
			case 'r':	goto yy109;
			case 's':	goto yy110;
			case 't':	goto yy111;
			default:	goto yy100;
			}
yy100:
			++YYCURSOR;
yy101:
#line 432 "txt2bin.re"
			{ goto s_err; }
#line 1301 "txt2bin.cpp"
yy102:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy102;
			default:	goto yy104;
			}
yy104:
#line 421 "txt2bin.re"
			{ goto s_4; }
#line 1314 "txt2bin.cpp"
yy105:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy112;
			default:	goto yy101;
			}
yy106:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy114;
			default:	goto yy101;
			}
yy107:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy115;
			default:	goto yy101;
			}
yy108:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'u':	goto yy116;
			default:	goto yy101;
			}
yy109:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy117;
			default:	goto yy101;
			}
yy110:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy118;
			default:	goto yy101;
			}
yy111:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy119;
			case 'e':	goto yy120;
			case 'g':	goto yy121;
			case 'p':	goto yy122;
			default:	goto yy101;
			}
yy112:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy123;
			default:	goto yy113;
			}
yy113:
			YYCURSOR = YYMARKER;
			goto yy101;
yy114:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy124;
			default:	goto yy113;
			}
yy115:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy125;
			default:	goto yy113;
			}
yy116:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy127;
			default:	goto yy113;
			}
yy117:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy129;
			default:	goto yy113;
			}
yy118:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy130;
			default:	goto yy113;
			}
yy119:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy131;
			default:	goto yy113;
			}
yy120:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy132;
			default:	goto yy113;
			}
yy121:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy133;
			default:	goto yy113;
			}
yy122:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy134;
			default:	goto yy113;
			}
yy123:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy135;
			default:	goto yy113;
			}
yy124:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy136;
			default:	goto yy113;
			}
yy125:
			++YYCURSOR;
#line 426 "txt2bin.re"
			{ item.type = GetOp; goto s_2; }
#line 1439 "txt2bin.cpp"
yy127:
			++YYCURSOR;
#line 425 "txt2bin.re"
			{ item.type = PutOp; goto s_2; }
#line 1444 "txt2bin.cpp"
yy129:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy138;
			default:	goto yy113;
			}
yy130:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy140;
			default:	goto yy113;
			}
yy131:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy142;
			default:	goto yy113;
			}
yy132:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy143;
			default:	goto yy113;
			}
yy133:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy145;
			default:	goto yy113;
			}
yy134:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy147;
			default:	goto yy113;
			}
yy135:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy149;
			default:	goto yy113;
			}
yy136:
			++YYCURSOR;
#line 422 "txt2bin.re"
			{ item.type = LoclOp; goto s_3; }
#line 1491 "txt2bin.cpp"
yy138:
			++YYCURSOR;
#line 424 "txt2bin.re"
			{ item.type = RecvOp; goto s_2; }
#line 1496 "txt2bin.cpp"
yy140:
			++YYCURSOR;
#line 423 "txt2bin.re"
			{ item.type = SendOp; goto s_2; }
#line 1501 "txt2bin.cpp"
yy142:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy150;
			default:	goto yy113;
			}
yy143:
			++YYCURSOR;
#line 428 "txt2bin.re"
			{ item.type = CTWaitOp; goto s_35;}
#line 1512 "txt2bin.cpp"
yy145:
			++YYCURSOR;
#line 431 "txt2bin.re"
			{ item.type = tGetOp; goto s_2; }
#line 1517 "txt2bin.cpp"
yy147:
			++YYCURSOR;
#line 430 "txt2bin.re"
			{ item.type = tPutOp; goto s_2; }
#line 1522 "txt2bin.cpp"
yy149:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy151;
			default:	goto yy113;
			}
yy150:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy153;
			default:	goto yy113;
			}
yy151:
			++YYCURSOR;
#line 427 "txt2bin.re"
			{ item.type = AppendOp; goto s_29;}
#line 1539 "txt2bin.cpp"
yy153:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy154;
			default:	goto yy113;
			}
yy154:
			++YYCURSOR;
#line 429 "txt2bin.re"
			{ item.type = tAppendOp; goto s_29;}
#line 1550 "txt2bin.cpp"
		}
#line 433 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_5:
	state =5;
	// printf("Entered s_5\n");

		s->tok = cursor;

#line 1562 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy160;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy163;
			default:	goto yy158;
			}
yy158:
			++YYCURSOR;
#line 444 "txt2bin.re"
			{ goto s_err; }
#line 1628 "txt2bin.cpp"
yy160:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy160;
			default:	goto yy162;
			}
yy162:
#line 442 "txt2bin.re"
			{ goto s_5; }
#line 1641 "txt2bin.cpp"
yy163:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy163;
			default:	goto yy165;
			}
yy165:
#line 443 "txt2bin.re"
			{ item.label2 = add_label(s->tok, cursor); goto s_6; }
#line 1715 "txt2bin.cpp"
		}
#line 445 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_6:
	state = 6;
	// printf("Entered s_6\n");


#line 1727 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			case '\n':	goto yy173;
			case '\r':	goto yy175;
			default:	goto yy168;
			}
yy168:
			++YYCURSOR;
yy169:
#line 456 "txt2bin.re"
			{ goto s_err; }
#line 1744 "txt2bin.cpp"
yy170:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			default:	goto yy172;
			}
yy172:
#line 454 "txt2bin.re"
			{ goto s_6; }
#line 1757 "txt2bin.cpp"
yy173:
			++YYCURSOR;
#line 455 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1762 "txt2bin.cpp"
yy175:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy173;
			default:	goto yy169;
			}
		}
#line 457 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_7:
	state = 7;
	// printf("Entered s_7\n");


#line 1780 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			case '\n':	goto yy183;
			case '\r':	goto yy185;
			case 'c':	goto yy186;
			default:	goto yy178;
			}
yy178:
			++YYCURSOR;
yy179:
#line 469 "txt2bin.re"
			{ goto s_err; }
#line 1798 "txt2bin.cpp"
yy180:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			default:	goto yy182;
			}
yy182:
#line 466 "txt2bin.re"
			{ goto s_7; }
#line 1811 "txt2bin.cpp"
yy183:
			++YYCURSOR;
#line 468 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1816 "txt2bin.cpp"
yy185:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy183;
			default:	goto yy179;
			}
yy186:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy187;
			default:	goto yy179;
			}
yy187:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy189;
			default:	goto yy188;
			}
yy188:
			YYCURSOR = YYMARKER;
			goto yy179;
yy189:
			++YYCURSOR;
#line 467 "txt2bin.re"
			{ goto s_8; }
#line 1842 "txt2bin.cpp"
		}
#line 470 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_8:
	state =8;
	// printf("Entered s_8\n");

	s->tok = cursor;


#line 1856 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy195;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy198;
			default:	goto yy193;
			}
yy193:
			++YYCURSOR;
#line 483 "txt2bin.re"
			{ goto s_err; }
#line 1880 "txt2bin.cpp"
yy195:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy195;
			default:	goto yy197;
			}
yy197:
#line 481 "txt2bin.re"
			{ goto s_8; }
#line 1893 "txt2bin.cpp"
yy198:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy198;
			default:	goto yy200;
			}
yy200:
#line 482 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_9; }
#line 1914 "txt2bin.cpp"
		}
#line 484 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_9:
	state=9;
	// printf("Entered s_9\n");


#line 1926 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			case '\n':	goto yy208;
			case '\r':	goto yy210;
			default:	goto yy203;
			}
yy203:
			++YYCURSOR;
yy204:
#line 495 "txt2bin.re"
			{ goto s_err; }
#line 1943 "txt2bin.cpp"
yy205:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			default:	goto yy207;
			}
yy207:
#line 493 "txt2bin.re"
			{ goto s_9; }
#line 1956 "txt2bin.cpp"
yy208:
			++YYCURSOR;
#line 494 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1961 "txt2bin.cpp"
yy210:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy208;
			default:	goto yy204;
			}
		}
#line 496 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_10:
	state=10;
	// printf("Entered s_10\n");


#line 1979 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy215;
			case 'b':	goto yy218;
			default:	goto yy213;
			}
yy213:
			++YYCURSOR;
#line 507 "txt2bin.re"
			{ goto s_err; }
#line 1994 "txt2bin.cpp"
yy215:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy215;
			default:	goto yy217;
			}
yy217:
#line 505 "txt2bin.re"
			{ goto s_10; }
#line 2007 "txt2bin.cpp"
yy218:
			++YYCURSOR;
#line 506 "txt2bin.re"
			{ goto s_11; }
#line 2012 "txt2bin.cpp"
		}
#line 508 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_11:
	state = 11;
	// printf("Entered s_11\n");


#line 2024 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy224;
			case 'f':	goto yy227;
			case 't':	goto yy228;
			default:	goto yy222;
			}
yy222:
			++YYCURSOR;
yy223:
#line 520 "txt2bin.re"
			{ goto s_err; }
#line 2041 "txt2bin.cpp"
yy224:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy224;
			default:	goto yy226;
			}
yy226:
#line 517 "txt2bin.re"
			{ goto s_11; }
#line 2054 "txt2bin.cpp"
yy227:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy229;
			default:	goto yy223;
			}
yy228:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy231;
			default:	goto yy223;
			}
yy229:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy233;
			default:	goto yy230;
			}
yy230:
			YYCURSOR = YYMARKER;
			goto yy223;
yy231:
			++YYCURSOR;
#line 518 "txt2bin.re"
			{ if (item.type == SendOp || item.type == PutOp || item.type == tPutOp ) {goto s_12;} else {goto s_err;}; }
#line 2080 "txt2bin.cpp"
yy233:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy234;
			default:	goto yy230;
			}
yy234:
			++YYCURSOR;
#line 519 "txt2bin.re"
			{ if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp ) {goto s_12;} else {goto s_err;}; }
#line 2091 "txt2bin.cpp"
		}
#line 521 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_12:
	state = 12;
	// printf("Entered s_12\n");

	s->tok = cursor;


#line 2105 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy240;
			case '-':	goto yy243;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy244;
			default:	goto yy238;
			}
yy238:
			++YYCURSOR;
yy239:
#line 535 "txt2bin.re"
			{ goto s_err; }
#line 2131 "txt2bin.cpp"
yy240:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy240;
			default:	goto yy242;
			}
yy242:
#line 532 "txt2bin.re"
			{ goto s_12; }
#line 2144 "txt2bin.cpp"
yy243:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy247;
			default:	goto yy239;
			}
yy244:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy244;
			default:	goto yy246;
			}
yy246:
#line 534 "txt2bin.re"
			{ item.target = add_number(s->tok, cursor); if (item.type==tGetOp || item.type == tPutOp) {goto s_25;} else if (item.type==GetOp || item.type==PutOp) {goto s_39;} else { goto s_13;} }
#line 2171 "txt2bin.cpp"
yy247:
			++YYCURSOR;
#line 533 "txt2bin.re"
			{if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp) {item.target = std::numeric_limits<uint32_t>::max(); if (item.type==tGetOp) {goto s_25;} else if (item.type=GetOp) {goto s_39;} else {goto s_13;}} else {goto s_err;}; }
#line 2176 "txt2bin.cpp"
		}
#line 536 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_13:
	state = 13;
	// printf("Entered s_13\n");


#line 2188 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy253;
			case '\n':	goto yy256;
			case '\r':	goto yy258;
			case 'c':	goto yy259;
			case 'n':	goto yy260;
			case 't':	goto yy261;
			default:	goto yy251;
			}
yy251:
			++YYCURSOR;
yy252:
#line 550 "txt2bin.re"
			{ goto s_err; }
#line 2208 "txt2bin.cpp"
yy253:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy253;
			default:	goto yy255;
			}
yy255:
#line 545 "txt2bin.re"
			{ goto s_13; }
#line 2221 "txt2bin.cpp"
yy256:
			++YYCURSOR;
#line 549 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2226 "txt2bin.cpp"
yy258:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy256;
			default:	goto yy252;
			}
yy259:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy262;
			default:	goto yy252;
			}
yy260:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy264;
			default:	goto yy252;
			}
yy261:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy265;
			default:	goto yy252;
			}
yy262:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy266;
			default:	goto yy263;
			}
yy263:
			YYCURSOR = YYMARKER;
			goto yy252;
yy264:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy268;
			default:	goto yy263;
			}
yy265:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy270;
			default:	goto yy263;
			}
yy266:
			++YYCURSOR;
#line 547 "txt2bin.re"
			{ goto s_16; }
#line 2276 "txt2bin.cpp"
yy268:
			++YYCURSOR;
#line 548 "txt2bin.re"
			{ goto s_18; }
#line 2281 "txt2bin.cpp"
yy270:
			++YYCURSOR;
#line 546 "txt2bin.re"
			{ goto s_14; }
#line 2286 "txt2bin.cpp"
		}
#line 551 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_14:
	state = 14;
	// printf("Entered s_14\n");

	s->tok = cursor;


#line 2300 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy276;
			case '-':	goto yy279;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy280;
			default:	goto yy274;
			}
yy274:
			++YYCURSOR;
yy275:
#line 565 "txt2bin.re"
			{ goto s_err; }
#line 2326 "txt2bin.cpp"
yy276:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy276;
			default:	goto yy278;
			}
yy278:
#line 562 "txt2bin.re"
			{ goto s_14; }
#line 2339 "txt2bin.cpp"
yy279:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy283;
			default:	goto yy275;
			}
yy280:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy280;
			default:	goto yy282;
			}
yy282:
#line 564 "txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_15; }
#line 2366 "txt2bin.cpp"
yy283:
			++YYCURSOR;
#line 563 "txt2bin.re"
			{ item.tag = std::numeric_limits<uint32_t>::max(); goto s_15; }
#line 2371 "txt2bin.cpp"
		}
#line 566 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_15:
	state =15;
	// printf("Entered s_15\n");


#line 2383 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy289;
			case '\n':	goto yy292;
			case '\r':	goto yy294;
			case 'c':	goto yy295;
			case 'n':	goto yy296;
			default:	goto yy287;
			}
yy287:
			++YYCURSOR;
yy288:
#line 579 "txt2bin.re"
			{ goto s_err; }
#line 2402 "txt2bin.cpp"
yy289:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy289;
			default:	goto yy291;
			}
yy291:
#line 575 "txt2bin.re"
			{ goto s_15; }
#line 2415 "txt2bin.cpp"
yy292:
			++YYCURSOR;
#line 578 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2420 "txt2bin.cpp"
yy294:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy292;
			default:	goto yy288;
			}
yy295:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy297;
			default:	goto yy288;
			}
yy296:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy299;
			default:	goto yy288;
			}
yy297:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy300;
			default:	goto yy298;
			}
yy298:
			YYCURSOR = YYMARKER;
			goto yy288;
yy299:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy302;
			default:	goto yy298;
			}
yy300:
			++YYCURSOR;
#line 576 "txt2bin.re"
			{ goto s_16; }
#line 2458 "txt2bin.cpp"
yy302:
			++YYCURSOR;
#line 577 "txt2bin.re"
			{ goto s_18; }
#line 2463 "txt2bin.cpp"
		}
#line 580 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_16:
	state = 16;
	// printf("Entered s_16\n");

	s->tok = cursor;


#line 2477 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy308;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy311;
			default:	goto yy306;
			}
yy306:
			++YYCURSOR;
#line 593 "txt2bin.re"
			{ goto s_err; }
#line 2501 "txt2bin.cpp"
yy308:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy308;
			default:	goto yy310;
			}
yy310:
#line 591 "txt2bin.re"
			{ goto s_16; }
#line 2514 "txt2bin.cpp"
yy311:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy311;
			default:	goto yy313;
			}
yy313:
#line 592 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_17; }
#line 2535 "txt2bin.cpp"
		}
#line 594 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_17:
	state = 17;
	// printf("Entered s_17\n");


#line 2547 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy318;
			case '\n':	goto yy321;
			case '\r':	goto yy323;
			case 'n':	goto yy324;
			default:	goto yy316;
			}
yy316:
			++YYCURSOR;
yy317:
#line 606 "txt2bin.re"
			{ goto s_err; }
#line 2565 "txt2bin.cpp"
yy318:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy318;
			default:	goto yy320;
			}
yy320:
#line 603 "txt2bin.re"
			{ goto s_17; }
#line 2578 "txt2bin.cpp"
yy321:
			++YYCURSOR;
#line 605 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2583 "txt2bin.cpp"
yy323:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy321;
			default:	goto yy317;
			}
yy324:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy325;
			default:	goto yy317;
			}
yy325:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy327;
			default:	goto yy326;
			}
yy326:
			YYCURSOR = YYMARKER;
			goto yy317;
yy327:
			++YYCURSOR;
#line 604 "txt2bin.re"
			{ goto s_18; }
#line 2609 "txt2bin.cpp"
		}
#line 607 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_18:
	state = 18;
	// printf("Entered s_18\n");

	s->tok = cursor;


#line 2623 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy333;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy336;
			default:	goto yy331;
			}
yy331:
			++YYCURSOR;
#line 620 "txt2bin.re"
			{ goto s_err; }
#line 2647 "txt2bin.cpp"
yy333:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy333;
			default:	goto yy335;
			}
yy335:
#line 618 "txt2bin.re"
			{ goto s_18; }
#line 2660 "txt2bin.cpp"
yy336:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy336;
			default:	goto yy338;
			}
yy338:
#line 619 "txt2bin.re"
			{ item.nic = add_number(s->tok, cursor); goto s_19; }
#line 2681 "txt2bin.cpp"
		}
#line 621 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_19:
	state = 19;
	// printf("Entered s_19\n");


#line 2693 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy343;
			case '\n':	goto yy346;
			case '\r':	goto yy348;
			default:	goto yy341;
			}
yy341:
			++YYCURSOR;
yy342:
#line 632 "txt2bin.re"
			{ goto s_err; }
#line 2710 "txt2bin.cpp"
yy343:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy343;
			default:	goto yy345;
			}
yy345:
#line 630 "txt2bin.re"
			{ goto s_19; }
#line 2723 "txt2bin.cpp"
yy346:
			++YYCURSOR;
#line 631 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2728 "txt2bin.cpp"
yy348:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy346;
			default:	goto yy342;
			}
		}
#line 633 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_20:
	state = 20;
	// printf("Entered s_20\n");

	s->tok = cursor;


#line 2748 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy353;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy356;
			default:	goto yy351;
			}
yy351:
			++YYCURSOR;
#line 646 "txt2bin.re"
			{ goto s_err; }
#line 2772 "txt2bin.cpp"
yy353:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy353;
			default:	goto yy355;
			}
yy355:
#line 644 "txt2bin.re"
			{ goto s_20; }
#line 2785 "txt2bin.cpp"
yy356:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy356;
			default:	goto yy358;
			}
yy358:
#line 645 "txt2bin.re"
			{ s->rank = add_number(s->tok, cursor); s->curr_rank = s->rank; goto s_21; }
#line 2806 "txt2bin.cpp"
		}
#line 647 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_21:
	state = 21;
	// printf("Entered s_21\n");


#line 2818 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy363;
			case '{':	goto yy366;
			default:	goto yy361;
			}
yy361:
			++YYCURSOR;
#line 658 "txt2bin.re"
			{ goto s_err; }
#line 2833 "txt2bin.cpp"
yy363:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy363;
			default:	goto yy365;
			}
yy365:
#line 656 "txt2bin.re"
			{ goto s_21; }
#line 2846 "txt2bin.cpp"
yy366:
			++YYCURSOR;
#line 657 "txt2bin.re"
			{ goto s_0; }
#line 2851 "txt2bin.cpp"
		}
#line 659 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_22:
	state = 22;
	// printf("Entered s_22\n");

	s->tok = cursor;


#line 2865 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy372;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy375;
			default:	goto yy370;
			}
yy370:
			++YYCURSOR;
#line 672 "txt2bin.re"
			{ goto s_err; }
#line 2889 "txt2bin.cpp"
yy372:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy372;
			default:	goto yy374;
			}
yy374:
#line 670 "txt2bin.re"
			{ goto s_22; }
#line 2902 "txt2bin.cpp"
yy375:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy375;
			default:	goto yy377;
			}
yy377:
#line 671 "txt2bin.re"
			{ s->num_ranks = add_number(s->tok, cursor); goto s_0; }
#line 2923 "txt2bin.cpp"
		}
#line 673 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_23:
	state = 23;
	// printf("Entered s_23\n");


#line 2935 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy382;
			case '\r':	goto yy384;
			default:	goto yy380;
			}
yy380:
			++YYCURSOR;
yy381:
#line 683 "txt2bin.re"
			{ goto s_23; }
#line 2950 "txt2bin.cpp"
yy382:
			++YYCURSOR;
#line 682 "txt2bin.re"
			{ s->line++; continue;  }
#line 2955 "txt2bin.cpp"
yy384:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy382;
			default:	goto yy381;
			}
		}
#line 684 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_24:
	state = 24;
	// printf("Entered s_24\n");


#line 2973 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy389;
			case '\r':	goto yy391;
			case '*':	goto yy392;
			default:	goto yy387;
			}
yy387:
			++YYCURSOR;
yy388:
#line 695 "txt2bin.re"
			{ goto s_24; }
#line 2989 "txt2bin.cpp"
yy389:
			++YYCURSOR;
#line 694 "txt2bin.re"
			{ s->line++; goto s_24;  }
#line 2994 "txt2bin.cpp"
yy391:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy389;
			default:	goto yy388;
			}
yy392:
			yych = *++YYCURSOR;
			switch (yych) {
			case '/':	goto yy393;
			default:	goto yy388;
			}
yy393:
			++YYCURSOR;
#line 693 "txt2bin.re"
			{ continue; }
#line 3011 "txt2bin.cpp"
		}
#line 696 "txt2bin.re"


	assert(0==1); //We should never reach this line

/* Begin triggered operation parameters */
s_25:
    state = 25;


#line 3023 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy399;
			case 'w':	goto yy402;
			default:	goto yy397;
			}
yy397:
			++YYCURSOR;
yy398:
#line 707 "txt2bin.re"
			{ goto s_err; }
#line 3039 "txt2bin.cpp"
yy399:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy399;
			default:	goto yy401;
			}
yy401:
#line 705 "txt2bin.re"
			{ goto s_25; }
#line 3052 "txt2bin.cpp"
yy402:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'h':	goto yy403;
			default:	goto yy398;
			}
yy403:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy405;
			default:	goto yy404;
			}
yy404:
			YYCURSOR = YYMARKER;
			goto yy398;
yy405:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy406;
			default:	goto yy404;
			}
yy406:
			++YYCURSOR;
#line 706 "txt2bin.re"
			{ goto s_26; }
#line 3078 "txt2bin.cpp"
		}
#line 708 "txt2bin.re"


    assert(0==1);

s_26:
    state = 26;
    s->tok = cursor;

#line 3089 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy412;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy415;
			default:	goto yy410;
			}
yy410:
			++YYCURSOR;
#line 718 "txt2bin.re"
			{ goto s_err; }
#line 3113 "txt2bin.cpp"
yy412:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy412;
			default:	goto yy414;
			}
yy414:
#line 716 "txt2bin.re"
			{ goto s_26; }
#line 3126 "txt2bin.cpp"
yy415:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy415;
			default:	goto yy417;
			}
yy417:
#line 717 "txt2bin.re"
			{ item.ct = add_number(s->tok, cursor); goto s_27; }
#line 3147 "txt2bin.cpp"
		}
#line 719 "txt2bin.re"


    assert(0==1);

s_27:
    state = 27;


#line 3158 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy422;
			case 'r':	goto yy425;
			default:	goto yy420;
			}
yy420:
			++YYCURSOR;
yy421:
#line 729 "txt2bin.re"
			{ goto s_err; }
#line 3174 "txt2bin.cpp"
yy422:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy422;
			default:	goto yy424;
			}
yy424:
#line 727 "txt2bin.re"
			{ goto s_27; }
#line 3187 "txt2bin.cpp"
yy425:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy426;
			default:	goto yy421;
			}
yy426:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy428;
			default:	goto yy427;
			}
yy427:
			YYCURSOR = YYMARKER;
			goto yy421;
yy428:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy429;
			default:	goto yy427;
			}
yy429:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy430;
			default:	goto yy427;
			}
yy430:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy431;
			default:	goto yy427;
			}
yy431:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy432;
			default:	goto yy427;
			}
yy432:
			++YYCURSOR;
#line 728 "txt2bin.re"
			{ goto s_28; }
#line 3231 "txt2bin.cpp"
		}
#line 730 "txt2bin.re"


    assert(0==1);

s_28:
    state = 28;
    s->tok = cursor;

#line 3242 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy438;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy441;
			default:	goto yy436;
			}
yy436:
			++YYCURSOR;
#line 740 "txt2bin.re"
			{ goto s_err; }
#line 3266 "txt2bin.cpp"
yy438:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy438;
			default:	goto yy440;
			}
yy440:
#line 738 "txt2bin.re"
			{ goto s_28; }
#line 3279 "txt2bin.cpp"
yy441:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy441;
			default:	goto yy443;
			}
yy443:
#line 739 "txt2bin.re"
			{ item.threshold = add_number(s->tok, cursor); if (item.type==tAppendOp) {goto s_34;} else {goto s_39;} }
#line 3300 "txt2bin.cpp"
		}
#line 741 "txt2bin.re"


    assert(0==1);
/* End triggered ooeration parameters */

/* Begin Append/tAppend */
s_29:
    state=29;
    s->tok = cursor;

#line 3313 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy448;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy451;
			default:	goto yy446;
			}
yy446:
			++YYCURSOR;
#line 753 "txt2bin.re"
			{ goto s_err; }
#line 3337 "txt2bin.cpp"
yy448:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy448;
			default:	goto yy450;
			}
yy450:
#line 751 "txt2bin.re"
			{ goto s_29; }
#line 3350 "txt2bin.cpp"
yy451:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy451;
			default:	goto yy453;
			}
yy453:
#line 752 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_38; }
#line 3371 "txt2bin.cpp"
		}
#line 754 "txt2bin.re"



s_30:
    state=30;


#line 3381 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy458;
			case 't':	goto yy461;
			default:	goto yy456;
			}
yy456:
			++YYCURSOR;
yy457:
#line 763 "txt2bin.re"
			{ goto s_err; }
#line 3397 "txt2bin.cpp"
yy458:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy458;
			default:	goto yy460;
			}
yy460:
#line 761 "txt2bin.re"
			{ goto s_30; }
#line 3410 "txt2bin.cpp"
yy461:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy462;
			default:	goto yy457;
			}
yy462:
			++YYCURSOR;
#line 762 "txt2bin.re"
			{ goto s_31; }
#line 3421 "txt2bin.cpp"
		}
#line 764 "txt2bin.re"


s_31:
    state=31;

#line 3429 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy468;
			case 'o':	goto yy471;
			case 'p':	goto yy472;
			default:	goto yy466;
			}
yy466:
			++YYCURSOR;
yy467:
#line 772 "txt2bin.re"
			{ goto s_err; }
#line 3446 "txt2bin.cpp"
yy468:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy468;
			default:	goto yy470;
			}
yy470:
#line 769 "txt2bin.re"
			{ goto s_31; }
#line 3459 "txt2bin.cpp"
yy471:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'v':	goto yy473;
			default:	goto yy467;
			}
yy472:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy475;
			default:	goto yy467;
			}
yy473:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy476;
			default:	goto yy474;
			}
yy474:
			YYCURSOR = YYMARKER;
			goto yy467;
yy475:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy477;
			default:	goto yy474;
			}
yy476:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy478;
			default:	goto yy474;
			}
yy477:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy479;
			default:	goto yy474;
			}
yy478:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'f':	goto yy480;
			default:	goto yy474;
			}
yy479:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy481;
			default:	goto yy474;
			}
yy480:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy482;
			default:	goto yy474;
			}
yy481:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy483;
			default:	goto yy474;
			}
yy482:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy484;
			default:	goto yy474;
			}
yy483:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy485;
			default:	goto yy474;
			}
yy484:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy486;
			default:	goto yy474;
			}
yy485:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'y':	goto yy487;
			default:	goto yy474;
			}
yy486:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy488;
			default:	goto yy474;
			}
yy487:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy489;
			default:	goto yy474;
			}
yy488:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy490;
			default:	goto yy474;
			}
yy489:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy491;
			default:	goto yy474;
			}
yy490:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy492;
			default:	goto yy474;
			}
yy491:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy493;
			default:	goto yy474;
			}
yy492:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy494;
			default:	goto yy474;
			}
yy493:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy495;
			default:	goto yy474;
			}
yy494:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy496;
			default:	goto yy474;
			}
yy495:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy498;
			default:	goto yy474;
			}
yy496:
			++YYCURSOR;
#line 770 "txt2bin.re"
			{ item.options |= OPT_OVERFLOW_LIST; goto s_32; }
#line 3611 "txt2bin.cpp"
yy498:
			++YYCURSOR;
#line 771 "txt2bin.re"
			{ item.options |= OPT_PRIORITY_LIST; goto s_32; }
#line 3616 "txt2bin.cpp"
		}
#line 773 "txt2bin.re"


s_32:
    state=32;

#line 3624 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy504;
			case 'a':	goto yy507;
			default:	goto yy502;
			}
yy502:
			++YYCURSOR;
yy503:
#line 780 "txt2bin.re"
			{ goto s_err; }
#line 3640 "txt2bin.cpp"
yy504:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy504;
			default:	goto yy506;
			}
yy506:
#line 778 "txt2bin.re"
			{ goto s_32; }
#line 3653 "txt2bin.cpp"
yy507:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'l':	goto yy508;
			default:	goto yy503;
			}
yy508:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy510;
			default:	goto yy509;
			}
yy509:
			YYCURSOR = YYMARKER;
			goto yy503;
yy510:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy511;
			default:	goto yy509;
			}
yy511:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy512;
			default:	goto yy509;
			}
yy512:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy513;
			default:	goto yy509;
			}
yy513:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy514;
			default:	goto yy509;
			}
yy514:
			++YYCURSOR;
#line 779 "txt2bin.re"
			{ goto s_33; }
#line 3697 "txt2bin.cpp"
		}
#line 781 "txt2bin.re"


s_33:
    state=33;
    s->tok = cursor;

#line 3706 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy520;
			case '-':	goto yy523;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy524;
			default:	goto yy518;
			}
yy518:
			++YYCURSOR;
yy519:
#line 790 "txt2bin.re"
			{ goto s_err; }
#line 3732 "txt2bin.cpp"
yy520:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy520;
			default:	goto yy522;
			}
yy522:
#line 787 "txt2bin.re"
			{ goto s_33; }
#line 3745 "txt2bin.cpp"
yy523:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy527;
			default:	goto yy519;
			}
yy524:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy524;
			default:	goto yy526;
			}
yy526:
#line 788 "txt2bin.re"
			{ item.target = add_number(s->tok, cursor); if (item.type == tAppendOp)  { goto s_25; } else {goto s_39;} }
#line 3772 "txt2bin.cpp"
yy527:
			++YYCURSOR;
#line 789 "txt2bin.re"
			{ item.target = std::numeric_limits<uint32_t>::max(); if (item.type == tAppendOp)  { goto s_25; } else {goto s_39;} }
#line 3777 "txt2bin.cpp"
		}
#line 791 "txt2bin.re"


s_34:
    state=34;


#line 3786 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy533;
			case '\n':	goto yy536;
			case '\r':	goto yy538;
			case 'c':	goto yy539;
			case 'n':	goto yy540;
			case 't':	goto yy541;
			case 'u':	goto yy542;
			default:	goto yy531;
			}
yy531:
			++YYCURSOR;
yy532:
#line 803 "txt2bin.re"
			{ goto s_err; }
#line 3807 "txt2bin.cpp"
yy533:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy533;
			default:	goto yy535;
			}
yy535:
#line 797 "txt2bin.re"
			{ goto s_34; }
#line 3820 "txt2bin.cpp"
yy536:
			++YYCURSOR;
#line 802 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 3825 "txt2bin.cpp"
yy538:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy536;
			default:	goto yy532;
			}
yy539:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy543;
			default:	goto yy532;
			}
yy540:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy545;
			default:	goto yy532;
			}
yy541:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy546;
			default:	goto yy532;
			}
yy542:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 's':	goto yy547;
			default:	goto yy532;
			}
yy543:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy548;
			default:	goto yy544;
			}
yy544:
			YYCURSOR = YYMARKER;
			goto yy532;
yy545:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy550;
			default:	goto yy544;
			}
yy546:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy552;
			default:	goto yy544;
			}
yy547:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy554;
			default:	goto yy544;
			}
yy548:
			++YYCURSOR;
#line 800 "txt2bin.re"
			{ goto s_16; }
#line 3887 "txt2bin.cpp"
yy550:
			++YYCURSOR;
#line 801 "txt2bin.re"
			{ goto s_18; }
#line 3892 "txt2bin.cpp"
yy552:
			++YYCURSOR;
#line 799 "txt2bin.re"
			{ goto s_14; }
#line 3897 "txt2bin.cpp"
yy554:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy555;
			default:	goto yy544;
			}
yy555:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy556;
			default:	goto yy544;
			}
yy556:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy557;
			default:	goto yy544;
			}
yy557:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy558;
			default:	goto yy544;
			}
yy558:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy559;
			default:	goto yy544;
			}
yy559:
			++YYCURSOR;
#line 798 "txt2bin.re"
			{ item.options |= OPT_USE_ONCE; goto s_13; }
#line 3932 "txt2bin.cpp"
		}
#line 804 "txt2bin.re"

/* End Append/tAppend */

/* Begin CTWait */
s_35:
    state=35;
    s->tok = cursor;

#line 3943 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy565;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy568;
			default:	goto yy563;
			}
yy563:
			++YYCURSOR;
#line 814 "txt2bin.re"
			{ goto s_err; }
#line 3967 "txt2bin.cpp"
yy565:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy565;
			default:	goto yy567;
			}
yy567:
#line 812 "txt2bin.re"
			{ goto s_35; }
#line 3980 "txt2bin.cpp"
yy568:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy568;
			default:	goto yy570;
			}
yy570:
#line 813 "txt2bin.re"
			{ item.ct = add_number(s->tok, cursor); goto s_36; }
#line 4001 "txt2bin.cpp"
		}
#line 815 "txt2bin.re"


s_36:
    state=36;


#line 4010 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy575;
			case 'f':	goto yy578;
			default:	goto yy573;
			}
yy573:
			++YYCURSOR;
yy574:
#line 823 "txt2bin.re"
			{ goto s_err; }
#line 4026 "txt2bin.cpp"
yy575:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy575;
			default:	goto yy577;
			}
yy577:
#line 821 "txt2bin.re"
			{ goto s_36; }
#line 4039 "txt2bin.cpp"
yy578:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'o':	goto yy579;
			default:	goto yy574;
			}
yy579:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy581;
			default:	goto yy580;
			}
yy580:
			YYCURSOR = YYMARKER;
			goto yy574;
yy581:
			++YYCURSOR;
#line 822 "txt2bin.re"
			{ goto s_37; }
#line 4059 "txt2bin.cpp"
		}
#line 824 "txt2bin.re"


s_37:
    state=37;
    s->tok = cursor;

#line 4068 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy587;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy590;
			default:	goto yy585;
			}
yy585:
			++YYCURSOR;
#line 832 "txt2bin.re"
			{ goto s_err; }
#line 4092 "txt2bin.cpp"
yy587:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy587;
			default:	goto yy589;
			}
yy589:
#line 830 "txt2bin.re"
			{ goto s_37; }
#line 4105 "txt2bin.cpp"
yy590:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy590;
			default:	goto yy592;
			}
yy592:
#line 831 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 4126 "txt2bin.cpp"
		}
#line 833 "txt2bin.re"


/* End CTWait */

//I forgot it in the append...
s_38:
	state=38;
	// printf("Entered s_10\n");


#line 4139 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy597;
			case 'b':	goto yy600;
			default:	goto yy595;
			}
yy595:
			++YYCURSOR;
#line 845 "txt2bin.re"
			{ goto s_err; }
#line 4154 "txt2bin.cpp"
yy597:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy597;
			default:	goto yy599;
			}
yy599:
#line 843 "txt2bin.re"
			{ goto s_38; }
#line 4167 "txt2bin.cpp"
yy600:
			++YYCURSOR;
#line 844 "txt2bin.re"
			{ goto s_30; }
#line 4172 "txt2bin.cpp"
		}
#line 846 "txt2bin.re"


/* Read CT param */
s_39:
	state=39;


#line 4182 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy606;
			case 'c':	goto yy609;
			default:	goto yy604;
			}
yy604:
			++YYCURSOR;
yy605:
#line 855 "txt2bin.re"
			{ goto s_err; }
#line 4198 "txt2bin.cpp"
yy606:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy606;
			default:	goto yy608;
			}
yy608:
#line 853 "txt2bin.re"
			{ goto s_39; }
#line 4211 "txt2bin.cpp"
yy609:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy610;
			default:	goto yy605;
			}
yy610:
			++YYCURSOR;
#line 854 "txt2bin.re"
			{ goto s_40; }
#line 4222 "txt2bin.cpp"
		}
#line 856 "txt2bin.re"


s_40:
	state=40;
    s->tok = cursor;

#line 4231 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy616;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy619;
			default:	goto yy614;
			}
yy614:
			++YYCURSOR;
#line 864 "txt2bin.re"
			{ goto s_err; }
#line 4255 "txt2bin.cpp"
yy616:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy616;
			default:	goto yy618;
			}
yy618:
#line 862 "txt2bin.re"
			{ goto s_40; }
#line 4268 "txt2bin.cpp"
yy619:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy619;
			default:	goto yy621;
			}
yy621:
#line 863 "txt2bin.re"
			{ item.oct = add_number(s->tok, cursor); if (item.type==AppendOp || item.type==tAppendOp) { goto s_34;} else {goto s_13;} }
#line 4289 "txt2bin.cpp"
		}
#line 865 "txt2bin.re"




s_err:

	fprintf(stderr, "Error in line %i:\n", s->line);

	uchar* nlbef = s->bot;
	uchar* nlaft = s->lim;
	// find the last newline before the error
	uchar* c = cursor-2;
	while (c>s->bot) {
		c--;
		if (*c == '\n') {
			nlbef = c;
			break;
		}
	}
	// find the next newline after the error
	c = cursor-2;
	while (c<s->lim) {
		c++;
		if (*c == '\n') {
			nlaft = c;
			break;
		}
	}

	for (uchar* c = nlbef+1; c<nlaft; c++) {
		fprintf(stderr, "%c", *c);
	}
	fprintf(stderr, "\n");

	for (int cnt=0; cnt<(cursor-2)-nlbef; cnt++) {
		fprintf(stderr, " ");
	}
	fprintf(stderr, "^\n");


	switch(state) {
		case 0:
			fprintf(stderr,"Expected: \"rank\", \"num_ranks\", \"calc\", \"send\", \"recv\", an identifier, \"}\" or \"\\n\"\n");
			break;
		case 1:
			fprintf(stderr,"Expected: \":\", \"requires\" or \"irequires\"\n");
			break;
		case 2:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 3:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 4:
			fprintf(stderr,"Expected: \"calc\", \"send\" or \"recv\"\n");
			break;
		case 5:
			fprintf(stderr,"Expected: an identifier\n");
			break;
		case 6:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 7:
			fprintf(stderr,"Expected: \"cpu\" or \"\\n\"\n");
			break;
		case 8:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 9:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 10:
			fprintf(stderr,"Expected: \"b\"\n");
			break;
		case 11:
			if (item.type == SendOp) fprintf(stderr,"Expected: \"to\"\n");
			else if (item.type == RecvOp) fprintf(stderr,"Expected: \"from\"\n");
			else fprintf(stderr,"Expected: \"to\" or \"from\"\n");
			break;
		case 12:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 13:
			fprintf(stderr,"Expected: \"tag\", \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 14:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 15:
			fprintf(stderr,"Expected: \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 16:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 17:
			fprintf(stderr,"Expected: \"nic\" or \"\\n\"\n");
			break;
		case 18:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 19:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 20:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 21:
			fprintf(stderr,"Expected: \"{\"\n");
			break;
		case 22:
			fprintf(stderr,"Expected: an integer\n");
			break;
	}

	if (*(cursor-1) == '\n') {
		fprintf(stderr, "Instead the schedule contained: \"\\n\"\n");
	}
	else {
		fprintf(stderr, "Instead the schedule contained: \"%c\"\n", *(cursor-1));
	}



	exit(EXIT_FAILURE);

}
}

main(int argc, char **argv){

	Scanner in;
	int lastprogress = 0;

	if (cmdline_parser(argc, argv, &args_info) != 0) {
		fprintf(stderr, "Couldn't parse command line arguments!\n");
		exit(EXIT_FAILURE);
	}

    memset((char*) &in, 0, sizeof(in));
   	in.fd = fopen(args_info.input_arg, "r");
	if (in.fd == NULL) {
		fprintf(stderr, "Couldn't open input file %s!\n", args_info.input_arg);
		exit(EXIT_FAILURE);
	}
	in.idtbl = new std::map<std::string, goalop_t>;

	uint32_t numranks = -1;

	while (true) {

		in.schedule = new Goal;

		scan(&in);

		if (in.num_ranks < 1) {
			fprintf(stderr, "Parse error: Number of Ranks undefined\n");
			exit(EXIT_FAILURE);
		}

		in.idtbl->clear();

		in.schedule->SetRank(in.curr_rank);
		in.schedule->SetNumRanks(in.num_ranks);
		in.schedule->SerializeSchedule(args_info.output_arg);
		delete in.schedule;
		int newprogress = round((((double) in.curr_rank) / in.num_ranks)*100);
		if (args_info.progress_given && (newprogress > lastprogress) ) {
			lastprogress = newprogress;
			printf("Progress %i%% - parsed schedule %i/%i\n", lastprogress, in.curr_rank, in.num_ranks);
		}
		if (in.curr_rank+1 == in.num_ranks) break;
	}

	free(in.bot);
	exit(EXIT_SUCCESS);
}
