/* Generated by re2c 0.16 on Wed Nov 22 17:34:44 2017 */
#line 1 "./txt2bin.re"
#include <map>
#include <math.h>
#include <string>
#include <limits>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>

#include "../simulator/Goal.hpp"
#include "txt2bin_cmdline.h"

typedef unsigned int uint;
typedef unsigned char uchar;

#define BSIZE   10240

#define YYCTYPE     uchar
#define YYCURSOR    cursor
#define YYLIMIT     s->lim
#define YYMARKER    s->ptr
#define YYFILL(n)   {cursor = fill(s, cursor, n);}


#define OPT_USE_ONCE 1
#define OPT_OVERFLOW_LIST 2
#define OPT_PRIORITY_LIST 4


#define RET(i)  {s->cur = cursor; return i;}

gengetopt_args_info args_info;

typedef struct Scanner {
    FILE*       fd;
    uchar       *bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint        line;
    int         rank;
    uint32_t    curr_rank, num_ranks;
    Goal*       schedule;
    std::map<std::string, goalop_t>* idtbl;
} Scanner;

typedef struct Item {
    char type;
    char *label1;
    char *label2;
    uint64_t size;
    uint32_t target;
    uint32_t tag;
    uint8_t cpu;
    uint8_t nic;
    char options;
    uint32_t oct; //my ct
    uint32_t ct; //triggering ct
    uint64_t threshold;
    uint32_t hh, ph, ch; //handlers
    uint32_t mem; //hpu initial state
    uint64_t arg[4];
} Item;

enum OpTypes {
    Undefined,
    SendOp,
    RecvOp,
    LoclOp,
    Gem5Op,
    StartDependency,
    Dependency,
    AppendOp,
    PutOp,
    GetOp,
    CTWaitOp,
    tAppendOp,
    tPutOp,
    tGetOp
};

inline uint64_t add_number(unsigned char *s, unsigned char *e) {

    uint64_t num = 0;
    --s;
    while(++s < e) num = num * 10 + (*s - '0');

    return num;
}

inline void insert_id(Scanner *s, char *id, goalop_t op) {

    s->idtbl->insert(std::make_pair(std::string(id), op));
    free(id);
}

inline goalop_t retrieve_id(Scanner *s, char *id) {

    std::map<std::string, goalop_t>::iterator it;
    it = s->idtbl->find(std::string(id));
    if (it == s->idtbl->end()) {
        fprintf(stderr, "A dependency references label %s, which is undefined!\n", id);
        exit(EXIT_FAILURE);
    }
    free(id);
    return it->second;
}

void process_item(Scanner *s, Item *item) {

/*
    printf("Parsed Item:\n");
    printf("  Type: ");
    if (item->type == Undefined) printf("Undefined\n");
    if (item->type == SendOp) printf("Send\n");
    if (item->type == RecvOp) printf("Recv\n");
    if (item->type == LoclOp) printf("LoclOp\n");
    if (item->type == StartDependency) printf("IRequires\n");
    if (item->type == Dependency) printf("Requires\n");
    printf("  Label1: %s\n", item->label1);
    printf("  Label2: %s\n", item->label2);
    printf("  Size: %i\n", item->size);
    printf("  Target: %i\n", item->target);
    printf("  Tag: %i\n", item->tag);
    printf("  CPU: %i\n", item->cpu);
    printf("  NIC: %i\n", item->nic);
*/

    goalop_t op, op2;

    switch (item->type) {
        case Undefined:
            fprintf(stderr, "Error while parsing, attempt to add a undefined operation\n");
            exit(EXIT_FAILURE);
            break;
        case SendOp:
            op = s->schedule->Send(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case RecvOp:
            op = s->schedule->Recv(item->target, s->rank, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case LoclOp:
            op = s->schedule->Calc(s->rank, item->size, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case Gem5Op:
        //  printf("Gem5Op: %u %u\n",item->tag,item->size) ;
            op = s->schedule->Gem5Calc(s->rank, item->tag, item->size, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case PutOp:
	   // printf("PutOp: %u %u %u %u\n",item->hh, item->ph, item->ch, item->mem) ;
            op = s->schedule->Put(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic, item->arg[0], item->arg[1], item->arg[2], item->arg[3]);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case GetOp:
            op = s->schedule->Get(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case AppendOp:
	        if(item->mem == (uint32_t)-1) item->mem = 0;
            printf("arg1: %lu\n",item->arg[0]);
            op = s->schedule->Append(s->rank, item->oct, item->target, item->size, item->tag, item->options, item->cpu, item->nic, item->hh, item->ph, item->ch,item->mem,item->arg[0], item->arg[1], item->arg[2], item->arg[3]);

            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case CTWaitOp:
            op = s->schedule->CTWait(s->rank, item->ct, item->size, item->cpu);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tAppendOp:
	    if(item->mem == (uint32_t)-1) item->mem = 0;	
            op = s->schedule->tAppend(s->rank, item->oct, item->target, item->size, item->tag, item->options, item->cpu, item->nic, item->ct, item->threshold, item->hh, item->ph, item->ch, item->mem, item->arg[0], item->arg[1], item->arg[2], item->arg[3]);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tPutOp:
            op = s->schedule->tPut(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic,item->arg[0], item->arg[1], item->arg[2], item->arg[3], item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case tGetOp:
            op = s->schedule->tGet(s->rank, item->oct, item->target, item->size, item->tag, item->cpu, item->nic, item->ct, item->threshold);
            if (item->label1 != NULL) insert_id(s, item->label1, op);
            break;
        case StartDependency:
            op = retrieve_id(s, item->label1);
            op2 = retrieve_id(s, item->label2);
            assert(op != NULL);
            assert(op2 != NULL);
            s->schedule->StartDependency(op, op2);
            break;
        case Dependency:
            op = retrieve_id(s, item->label1);
            op2 = retrieve_id(s, item->label2);
            assert(op != NULL);
            assert(op2 != NULL);
            s->schedule->Dependency(op, op2);
            break;
        default:
            break;
    }
}

inline char* add_label(unsigned char *s, unsigned char *e) {

    char *buf = NULL;

    buf = (char *) malloc((e-s)+1);
    memcpy((void *) buf, (void *) s, (size_t) (e-s));
    buf[e-s] = '\0';

    return buf;

}


uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

    if(!s->eof) {
        uint cnt = s->tok - s->bot;
        if(cnt){
            if ((s->lim - s->tok) < abs(s->bot - s->tok)) memcpy(s->bot, s->tok, s->lim - s->tok);
            else memmove(s->bot, s->tok, s->lim - s->tok);
            s->tok = s->bot;
            s->ptr -= cnt;
            cursor -= cnt;
            s->pos -= cnt;
            s->lim -= cnt;
        }
        if((s->top - s->lim) < BSIZE){
            uchar *buf = (uchar*) malloc(((s->lim - s->bot) + BSIZE)*sizeof(uchar));
            if ((s->lim - s->tok) > abs(s->tok - buf)) memmove(buf, s->tok, s->lim - s->tok);
            else memcpy(buf, s->tok, s->lim - s->tok);
            s->tok = buf;
            s->ptr = &buf[s->ptr - s->bot];
            cursor = &buf[cursor - s->bot];
            s->pos = &buf[s->pos - s->bot];
            s->lim = &buf[s->lim - s->bot];
            s->top = &s->lim[BSIZE];
            free(s->bot);
            s->bot = buf;
        }
        cnt = fread((char*) s->lim, 1, BSIZE, s->fd);
        if(cnt != BSIZE) {
            s->eof = &s->lim[cnt];
            *(s->eof)++ = '\n';
        }
        s->lim += cnt;
        //assert(cnt >= numtoread);
    }
    return cursor;
}

/*
uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

    static bool firstcall = true;

    if (firstcall) {

        void *buf;
        struct stat statbuf;

        int ret = fstat(fileno(s->fd), &statbuf);
        buf = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fileno(s->fd), 0);
        assert(buf != NULL);
        s->lim = (uchar*) buf;
        s->lim += statbuf.st_size;
        s->eof = s->lim;
        return (uchar*) buf;
    }
    else {
        assert(0==1);
    }
}
*/

int scan(Scanner *s) {

    //uchar *cursor = s->cur;

    static uchar *cursor = NULL;
    Item item;
    int state;

    for (;;) {

s_0:

    if ((cursor == s->eof) and (cursor != NULL)) {
        fprintf(stderr, "Reached the end of the inputfile - did you forget a closing bracket?\n");
        return s->rank;
    }

    s->tok = cursor;
    state = 0;

    // printf("Entered s_0\n");
    // if (((s->line % 100) == 0) or (s->line < 100)) printf("Line: %i\n", s->line);

    item.type = Undefined;
    item.label1 = NULL;
    item.label2 = NULL;
    item.cpu = 0;
    item.nic = 0;
    item.tag = 0;
    item.options = 0;
    item.ct = 0;
    item.threshold = 0;
    item.oct = -1;
    item.hh=item.ph=item.ch=-1;
    item.mem=-1;
    item.arg[0]=item.arg[1]=item.arg[2]=item.arg[3]=-1;
	


#line 323 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			case '\n':	goto yy7;
			case '\r':	goto yy9;
			case '/':	goto yy10;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'p':
			case 'q':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			case 'c':	goto yy14;
			case 'n':	goto yy15;
			case 'r':	goto yy16;
			case 's':	goto yy17;
			case '}':	goto yy18;
			default:	goto yy2;
			}
yy2:
			++YYCURSOR;
yy3:
#line 396 "./txt2bin.re"
			{ goto s_err; }
#line 394 "<stdout>"
yy4:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			default:	goto yy6;
			}
yy6:
#line 374 "./txt2bin.re"
			{ s->tok = cursor; }
#line 407 "<stdout>"
yy7:
			++YYCURSOR;
#line 394 "./txt2bin.re"
			{ s->line++; continue; }
#line 412 "<stdout>"
yy9:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy7;
			default:	goto yy3;
			}
yy10:
			yych = *++YYCURSOR;
			switch (yych) {
			case '*':	goto yy20;
			case '/':	goto yy22;
			default:	goto yy3;
			}
yy11:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy12:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy13;
			}
yy13:
#line 381 "./txt2bin.re"
			{ item.label1 = add_label(s->tok, cursor); goto s_1; }
#line 500 "<stdout>"
yy14:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy24;
			default:	goto yy12;
			}
yy15:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy25;
			default:	goto yy12;
			}
yy16:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy26;
			case 'e':	goto yy27;
			default:	goto yy12;
			}
yy17:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy28;
			default:	goto yy12;
			}
yy18:
			++YYCURSOR;
#line 395 "./txt2bin.re"
			{ if (s->rank == -1) goto s_err; int oldrank = s->rank; s->rank = -1; return oldrank; }
#line 530 "<stdout>"
yy20:
			++YYCURSOR;
#line 383 "./txt2bin.re"
			{ goto s_24; }
#line 535 "<stdout>"
yy22:
			++YYCURSOR;
#line 382 "./txt2bin.re"
			{ goto s_23; }
#line 540 "<stdout>"
yy24:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy29;
			default:	goto yy12;
			}
yy25:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy30;
			default:	goto yy12;
			}
yy26:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy31;
			default:	goto yy12;
			}
yy27:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy32;
			default:	goto yy12;
			}
yy28:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy33;
			default:	goto yy12;
			}
yy29:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy34;
			default:	goto yy12;
			}
yy30:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy36;
			default:	goto yy12;
			}
yy31:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy37;
			default:	goto yy12;
			}
yy32:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy39;
			default:	goto yy12;
			}
yy33:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy41;
			default:	goto yy12;
			}
yy34:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			case 'g':	goto yy43;
			default:	goto yy35;
			}
yy35:
#line 377 "./txt2bin.re"
			{ item.type = LoclOp;  goto s_3; }
#line 672 "<stdout>"
yy36:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy44;
			default:	goto yy12;
			}
yy37:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy38;
			}
yy38:
#line 379 "./txt2bin.re"
			{ goto s_20; }
#line 750 "<stdout>"
yy39:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy40;
			}
yy40:
#line 376 "./txt2bin.re"
			{ item.type = RecvOp;  goto s_2; }
#line 822 "<stdout>"
yy41:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy42;
			}
yy42:
#line 375 "./txt2bin.re"
			{ item.type = SendOp;  goto s_2; }
#line 894 "<stdout>"
yy43:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy45;
			default:	goto yy12;
			}
yy44:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy46;
			default:	goto yy12;
			}
yy45:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy47;
			default:	goto yy12;
			}
yy46:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy48;
			default:	goto yy12;
			}
yy47:
			yych = *++YYCURSOR;
			switch (yych) {
			case '5':	goto yy49;
			default:	goto yy12;
			}
yy48:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy51;
			default:	goto yy12;
			}
yy49:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy50;
			}
yy50:
#line 378 "./txt2bin.re"
			{ item.type = Gem5Op;  goto s_45; }
#line 1002 "<stdout>"
yy51:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy52;
			default:	goto yy12;
			}
yy52:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy53;
			}
yy53:
#line 380 "./txt2bin.re"
			{ goto s_22; }
#line 1080 "<stdout>"
		}
#line 397 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_1:
    state =1;

    // printf("Entered s_1\n");


#line 1093 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy58;
			case ':':	goto yy61;
			case 'i':	goto yy63;
			case 'r':	goto yy64;
			default:	goto yy56;
			}
yy56:
			++YYCURSOR;
yy57:
#line 411 "./txt2bin.re"
			{ goto s_err; }
#line 1111 "<stdout>"
yy58:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy58;
			default:	goto yy60;
			}
yy60:
#line 407 "./txt2bin.re"
			{ goto s_1; }
#line 1124 "<stdout>"
yy61:
			++YYCURSOR;
#line 408 "./txt2bin.re"
			{ goto s_4; }
#line 1129 "<stdout>"
yy63:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy65;
			default:	goto yy57;
			}
yy64:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy67;
			default:	goto yy57;
			}
yy65:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy68;
			default:	goto yy66;
			}
yy66:
			YYCURSOR = YYMARKER;
			goto yy57;
yy67:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy69;
			default:	goto yy66;
			}
yy68:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy70;
			default:	goto yy66;
			}
yy69:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy71;
			default:	goto yy66;
			}
yy70:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy72;
			default:	goto yy66;
			}
yy71:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy73;
			default:	goto yy66;
			}
yy72:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy74;
			default:	goto yy66;
			}
yy73:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy75;
			default:	goto yy66;
			}
yy74:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy76;
			default:	goto yy66;
			}
yy75:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy77;
			default:	goto yy66;
			}
yy76:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy78;
			default:	goto yy66;
			}
yy77:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy79;
			default:	goto yy66;
			}
yy78:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy81;
			default:	goto yy66;
			}
yy79:
			++YYCURSOR;
#line 409 "./txt2bin.re"
			{ item.type = Dependency;       goto s_5; }
#line 1227 "<stdout>"
yy81:
			++YYCURSOR;
#line 410 "./txt2bin.re"
			{ item.type = StartDependency;  goto s_5; }
#line 1232 "<stdout>"
		}
#line 412 "./txt2bin.re"

    assert(0==1); //We should never reach this line

s_2:
    state=2;

    // printf("Entered s_2\n");

        s->tok = cursor;

#line 1245 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy87;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy90;
			default:	goto yy85;
			}
yy85:
			++YYCURSOR;
#line 424 "./txt2bin.re"
			{ goto s_err; }
#line 1269 "<stdout>"
yy87:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy87;
			default:	goto yy89;
			}
yy89:
#line 422 "./txt2bin.re"
			{ goto s_2; }
#line 1282 "<stdout>"
yy90:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy90;
			default:	goto yy92;
			}
yy92:
#line 423 "./txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_10; }
#line 1303 "<stdout>"
		}
#line 425 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_3:
    state = 3;
    // printf("Entered s_3\n");

        s->tok = cursor;

#line 1316 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy97;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy100;
			default:	goto yy95;
			}
yy95:
			++YYCURSOR;
#line 437 "./txt2bin.re"
			{ goto s_err; }
#line 1340 "<stdout>"
yy97:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy97;
			default:	goto yy99;
			}
yy99:
#line 435 "./txt2bin.re"
			{ goto s_3; }
#line 1353 "<stdout>"
yy100:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy100;
			default:	goto yy102;
			}
yy102:
#line 436 "./txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 1374 "<stdout>"
		}
#line 438 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_4:
    state = 4;
    // printf("Entered s_4\n");


#line 1386 "<stdout>"
		{
			YYCTYPE yych;
			unsigned int yyaccept = 0;
			if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy107;
			case 'a':	goto yy110;
			case 'c':	goto yy111;
			case 'g':	goto yy112;
			case 'p':	goto yy113;
			case 'r':	goto yy114;
			case 's':	goto yy115;
			case 't':	goto yy116;
			default:	goto yy105;
			}
yy105:
			++YYCURSOR;
yy106:
#line 459 "./txt2bin.re"
			{ goto s_err; }
#line 1409 "<stdout>"
yy107:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy107;
			default:	goto yy109;
			}
yy109:
#line 447 "./txt2bin.re"
			{ goto s_4; }
#line 1422 "<stdout>"
yy110:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy117;
			default:	goto yy106;
			}
yy111:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy119;
			default:	goto yy106;
			}
yy112:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy120;
			default:	goto yy106;
			}
yy113:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'u':	goto yy121;
			default:	goto yy106;
			}
yy114:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy122;
			default:	goto yy106;
			}
yy115:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy123;
			default:	goto yy106;
			}
yy116:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy124;
			case 'e':	goto yy125;
			case 'g':	goto yy126;
			case 'p':	goto yy127;
			default:	goto yy106;
			}
yy117:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy128;
			default:	goto yy118;
			}
yy118:
			YYCURSOR = YYMARKER;
			if (yyaccept == 0) {
				goto yy106;
			} else {
				goto yy142;
			}
yy119:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy129;
			default:	goto yy118;
			}
yy120:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy130;
			default:	goto yy118;
			}
yy121:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy132;
			default:	goto yy118;
			}
yy122:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy134;
			default:	goto yy118;
			}
yy123:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy135;
			default:	goto yy118;
			}
yy124:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy136;
			default:	goto yy118;
			}
yy125:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy137;
			default:	goto yy118;
			}
yy126:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy138;
			default:	goto yy118;
			}
yy127:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy139;
			default:	goto yy118;
			}
yy128:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy140;
			default:	goto yy118;
			}
yy129:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy141;
			default:	goto yy118;
			}
yy130:
			++YYCURSOR;
#line 453 "./txt2bin.re"
			{ item.type = GetOp; goto s_2; }
#line 1558 "<stdout>"
yy132:
			++YYCURSOR;
#line 452 "./txt2bin.re"
			{ item.type = PutOp; goto s_2; }
#line 1563 "<stdout>"
yy134:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy143;
			default:	goto yy118;
			}
yy135:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy145;
			default:	goto yy118;
			}
yy136:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'p':	goto yy147;
			default:	goto yy118;
			}
yy137:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy148;
			default:	goto yy118;
			}
yy138:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy150;
			default:	goto yy118;
			}
yy139:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy152;
			default:	goto yy118;
			}
yy140:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy154;
			default:	goto yy118;
			}
yy141:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'g':	goto yy155;
			default:	goto yy142;
			}
yy142:
#line 448 "./txt2bin.re"
			{ item.type = LoclOp; goto s_3; }
#line 1616 "<stdout>"
yy143:
			++YYCURSOR;
#line 451 "./txt2bin.re"
			{ item.type = RecvOp; goto s_2; }
#line 1621 "<stdout>"
yy145:
			++YYCURSOR;
#line 450 "./txt2bin.re"
			{ item.type = SendOp; goto s_2; }
#line 1626 "<stdout>"
yy147:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy156;
			default:	goto yy118;
			}
yy148:
			++YYCURSOR;
#line 455 "./txt2bin.re"
			{ item.type = CTWaitOp; goto s_35;}
#line 1637 "<stdout>"
yy150:
			++YYCURSOR;
#line 458 "./txt2bin.re"
			{ item.type = tGetOp; goto s_2; }
#line 1642 "<stdout>"
yy152:
			++YYCURSOR;
#line 457 "./txt2bin.re"
			{ item.type = tPutOp; goto s_2; }
#line 1647 "<stdout>"
yy154:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy157;
			default:	goto yy118;
			}
yy155:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy159;
			default:	goto yy118;
			}
yy156:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy160;
			default:	goto yy118;
			}
yy157:
			++YYCURSOR;
#line 454 "./txt2bin.re"
			{ item.type = AppendOp; goto s_29;}
#line 1670 "<stdout>"
yy159:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy161;
			default:	goto yy118;
			}
yy160:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy162;
			default:	goto yy118;
			}
yy161:
			yych = *++YYCURSOR;
			switch (yych) {
			case '5':	goto yy164;
			default:	goto yy118;
			}
yy162:
			++YYCURSOR;
#line 456 "./txt2bin.re"
			{ item.type = tAppendOp; goto s_29;}
#line 1693 "<stdout>"
yy164:
			++YYCURSOR;
#line 449 "./txt2bin.re"
			{ item.type = Gem5Op;  goto s_45; }
#line 1698 "<stdout>"
		}
#line 460 "./txt2bin.re"

    assert(0==1); //We should never reach this line

s_5:
    state =5;
    // printf("Entered s_5\n");

        s->tok = cursor;

#line 1710 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy173;
			default:	goto yy168;
			}
yy168:
			++YYCURSOR;
#line 471 "./txt2bin.re"
			{ goto s_err; }
#line 1776 "<stdout>"
yy170:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			default:	goto yy172;
			}
yy172:
#line 469 "./txt2bin.re"
			{ goto s_5; }
#line 1789 "<stdout>"
yy173:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy173;
			default:	goto yy175;
			}
yy175:
#line 470 "./txt2bin.re"
			{ item.label2 = add_label(s->tok, cursor); goto s_6; }
#line 1863 "<stdout>"
		}
#line 472 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_6:
    state = 6;
    // printf("Entered s_6\n");


#line 1875 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			case '\n':	goto yy183;
			case '\r':	goto yy185;
			default:	goto yy178;
			}
yy178:
			++YYCURSOR;
yy179:
#line 483 "./txt2bin.re"
			{ goto s_err; }
#line 1892 "<stdout>"
yy180:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			default:	goto yy182;
			}
yy182:
#line 481 "./txt2bin.re"
			{ goto s_6; }
#line 1905 "<stdout>"
yy183:
			++YYCURSOR;
#line 482 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1910 "<stdout>"
yy185:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy183;
			default:	goto yy179;
			}
		}
#line 484 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_7:
    state = 7;
    // printf("Entered s_7\n");


#line 1928 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy190;
			case '\n':	goto yy193;
			case '\r':	goto yy195;
			case 'c':	goto yy196;
			default:	goto yy188;
			}
yy188:
			++YYCURSOR;
yy189:
#line 496 "./txt2bin.re"
			{ goto s_err; }
#line 1946 "<stdout>"
yy190:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy190;
			default:	goto yy192;
			}
yy192:
#line 493 "./txt2bin.re"
			{ goto s_7; }
#line 1959 "<stdout>"
yy193:
			++YYCURSOR;
#line 495 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1964 "<stdout>"
yy195:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy193;
			default:	goto yy189;
			}
yy196:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy197;
			default:	goto yy189;
			}
yy197:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy199;
			default:	goto yy198;
			}
yy198:
			YYCURSOR = YYMARKER;
			goto yy189;
yy199:
			++YYCURSOR;
#line 494 "./txt2bin.re"
			{ goto s_8; }
#line 1990 "<stdout>"
		}
#line 497 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_8:
    state =8;
    // printf("Entered s_8\n");

    s->tok = cursor;


#line 2004 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy208;
			default:	goto yy203;
			}
yy203:
			++YYCURSOR;
#line 510 "./txt2bin.re"
			{ goto s_err; }
#line 2028 "<stdout>"
yy205:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			default:	goto yy207;
			}
yy207:
#line 508 "./txt2bin.re"
			{ goto s_8; }
#line 2041 "<stdout>"
yy208:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy208;
			default:	goto yy210;
			}
yy210:
#line 509 "./txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_9; }
#line 2062 "<stdout>"
		}
#line 511 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_9:
    state=9;
    // printf("Entered s_9\n");


#line 2074 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy215;
			case '\n':	goto yy218;
			case '\r':	goto yy220;
			default:	goto yy213;
			}
yy213:
			++YYCURSOR;
yy214:
#line 522 "./txt2bin.re"
			{ goto s_err; }
#line 2091 "<stdout>"
yy215:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy215;
			default:	goto yy217;
			}
yy217:
#line 520 "./txt2bin.re"
			{ goto s_9; }
#line 2104 "<stdout>"
yy218:
			++YYCURSOR;
#line 521 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2109 "<stdout>"
yy220:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy218;
			default:	goto yy214;
			}
		}
#line 523 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_10:
    state=10;
    // printf("Entered s_10\n");


#line 2127 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy225;
			case 'b':	goto yy228;
			default:	goto yy223;
			}
yy223:
			++YYCURSOR;
#line 534 "./txt2bin.re"
			{ goto s_err; }
#line 2142 "<stdout>"
yy225:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy225;
			default:	goto yy227;
			}
yy227:
#line 532 "./txt2bin.re"
			{ goto s_10; }
#line 2155 "<stdout>"
yy228:
			++YYCURSOR;
#line 533 "./txt2bin.re"
			{ goto s_11; }
#line 2160 "<stdout>"
		}
#line 535 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_11:
    state = 11;
    // printf("Entered s_11\n");


#line 2172 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy234;
			case 'a':	goto yy237;
			case 'f':	goto yy238;
			case 't':	goto yy239;
			default:	goto yy232;
			}
yy232:
			++YYCURSOR;
yy233:
#line 551 "./txt2bin.re"
			{ goto s_err; }
#line 2190 "<stdout>"
yy234:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy234;
			default:	goto yy236;
			}
yy236:
#line 544 "./txt2bin.re"
			{ goto s_11; }
#line 2203 "<stdout>"
yy237:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy240;
			default:	goto yy233;
			}
yy238:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy242;
			default:	goto yy233;
			}
yy239:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy243;
			default:	goto yy233;
			}
yy240:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy245;
			default:	goto yy241;
			}
yy241:
			YYCURSOR = YYMARKER;
			goto yy233;
yy242:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy246;
			default:	goto yy241;
			}
yy243:
			++YYCURSOR;
#line 549 "./txt2bin.re"
			{ if (item.type == SendOp || item.type == PutOp || item.type == tPutOp ) {goto s_12;} else {goto s_err;}; }
#line 2241 "<stdout>"
yy245:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy247;
			case '2':	goto yy249;
			case '3':	goto yy251;
			case '4':	goto yy253;
			default:	goto yy241;
			}
yy246:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy255;
			default:	goto yy241;
			}
yy247:
			++YYCURSOR;
#line 545 "./txt2bin.re"
			{ if (item.type == PutOp|| item.type == tPutOp) {goto s_48;} else {goto s_err;}; }
#line 2261 "<stdout>"
yy249:
			++YYCURSOR;
#line 546 "./txt2bin.re"
			{ if (item.type == PutOp|| item.type == tPutOp) {goto s_49;} else {goto s_err;}; }
#line 2266 "<stdout>"
yy251:
			++YYCURSOR;
#line 547 "./txt2bin.re"
			{ if (item.type == PutOp|| item.type == tPutOp) {goto s_50;} else {goto s_err;}; }
#line 2271 "<stdout>"
yy253:
			++YYCURSOR;
#line 548 "./txt2bin.re"
			{ if (item.type == PutOp|| item.type == tPutOp) {goto s_51;} else {goto s_err;}; }
#line 2276 "<stdout>"
yy255:
			++YYCURSOR;
#line 550 "./txt2bin.re"
			{ if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp ) {goto s_12;} else {goto s_err;}; }
#line 2281 "<stdout>"
		}
#line 552 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_12:
    state = 12;
    // printf("Entered s_12\n");

    s->tok = cursor;


#line 2295 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy261;
			case '-':	goto yy264;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy265;
			default:	goto yy259;
			}
yy259:
			++YYCURSOR;
yy260:
#line 566 "./txt2bin.re"
			{ goto s_err; }
#line 2321 "<stdout>"
yy261:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy261;
			default:	goto yy263;
			}
yy263:
#line 563 "./txt2bin.re"
			{ goto s_12; }
#line 2334 "<stdout>"
yy264:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy268;
			default:	goto yy260;
			}
yy265:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy265;
			default:	goto yy267;
			}
yy267:
#line 565 "./txt2bin.re"
			{ item.target = add_number(s->tok, cursor); if (item.type==tGetOp || item.type == tPutOp) {goto s_25;} else if (item.type==GetOp || item.type==PutOp) {goto s_13;} else { goto s_13;} }
#line 2361 "<stdout>"
yy268:
			++YYCURSOR;
#line 564 "./txt2bin.re"
			{if (item.type == RecvOp || item.type == GetOp || item.type == tGetOp) {item.target = std::numeric_limits<uint32_t>::max(); if (item.type==tGetOp) {goto s_25;} else if (item.type==GetOp) {goto s_39;} else {goto s_13;}} else {goto s_err;}; }
#line 2366 "<stdout>"
		}
#line 567 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_13:
    state = 13;
    // printf("Entered s_13\n");


#line 2378 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy274;
			case '\n':	goto yy277;
			case '\r':	goto yy279;
			case 'c':	goto yy280;
			case 'n':	goto yy281;
			case 't':	goto yy282;
			default:	goto yy272;
			}
yy272:
			++YYCURSOR;
yy273:
#line 582 "./txt2bin.re"
			{ goto s_err; }
#line 2398 "<stdout>"
yy274:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy274;
			default:	goto yy276;
			}
yy276:
#line 576 "./txt2bin.re"
			{ goto s_13; }
#line 2411 "<stdout>"
yy277:
			++YYCURSOR;
#line 581 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2416 "<stdout>"
yy279:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy277;
			default:	goto yy273;
			}
yy280:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy283;
			case 't':	goto yy285;
			default:	goto yy273;
			}
yy281:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy287;
			default:	goto yy273;
			}
yy282:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy288;
			default:	goto yy273;
			}
yy283:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy289;
			default:	goto yy284;
			}
yy284:
			YYCURSOR = YYMARKER;
			goto yy273;
yy285:
			++YYCURSOR;
#line 580 "./txt2bin.re"
			{ goto s_40; }
#line 2455 "<stdout>"
yy287:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy291;
			default:	goto yy284;
			}
yy288:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy293;
			default:	goto yy284;
			}
yy289:
			++YYCURSOR;
#line 578 "./txt2bin.re"
			{ goto s_16; }
#line 2472 "<stdout>"
yy291:
			++YYCURSOR;
#line 579 "./txt2bin.re"
			{ goto s_18; }
#line 2477 "<stdout>"
yy293:
			++YYCURSOR;
#line 577 "./txt2bin.re"
			{ goto s_14; }
#line 2482 "<stdout>"
		}
#line 583 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_14:
    state = 14;
    // printf("Entered s_14\n");

    s->tok = cursor;


#line 2496 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy299;
			case '-':	goto yy302;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy303;
			default:	goto yy297;
			}
yy297:
			++YYCURSOR;
yy298:
#line 597 "./txt2bin.re"
			{ goto s_err; }
#line 2522 "<stdout>"
yy299:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy299;
			default:	goto yy301;
			}
yy301:
#line 594 "./txt2bin.re"
			{ goto s_14; }
#line 2535 "<stdout>"
yy302:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy306;
			default:	goto yy298;
			}
yy303:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy303;
			default:	goto yy305;
			}
yy305:
#line 596 "./txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_15; }
#line 2562 "<stdout>"
yy306:
			++YYCURSOR;
#line 595 "./txt2bin.re"
			{ item.tag = std::numeric_limits<uint32_t>::max(); goto s_15; }
#line 2567 "<stdout>"
		}
#line 598 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_15:
    state =15;
    // printf("Entered s_15\n");


#line 2579 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy312;
			case '\n':	goto yy315;
			case '\r':	goto yy317;
			case 'c':	goto yy318;
			case 'n':	goto yy319;
			default:	goto yy310;
			}
yy310:
			++YYCURSOR;
yy311:
#line 611 "./txt2bin.re"
			{ goto s_err; }
#line 2598 "<stdout>"
yy312:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy312;
			default:	goto yy314;
			}
yy314:
#line 607 "./txt2bin.re"
			{ goto s_15; }
#line 2611 "<stdout>"
yy315:
			++YYCURSOR;
#line 610 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2616 "<stdout>"
yy317:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy315;
			default:	goto yy311;
			}
yy318:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy320;
			default:	goto yy311;
			}
yy319:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy322;
			default:	goto yy311;
			}
yy320:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy323;
			default:	goto yy321;
			}
yy321:
			YYCURSOR = YYMARKER;
			goto yy311;
yy322:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy325;
			default:	goto yy321;
			}
yy323:
			++YYCURSOR;
#line 608 "./txt2bin.re"
			{ goto s_16; }
#line 2654 "<stdout>"
yy325:
			++YYCURSOR;
#line 609 "./txt2bin.re"
			{ goto s_18; }
#line 2659 "<stdout>"
		}
#line 612 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_16:
    state = 16;
    // printf("Entered s_16\n");

    s->tok = cursor;


#line 2673 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy331;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy334;
			default:	goto yy329;
			}
yy329:
			++YYCURSOR;
#line 625 "./txt2bin.re"
			{ goto s_err; }
#line 2697 "<stdout>"
yy331:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy331;
			default:	goto yy333;
			}
yy333:
#line 623 "./txt2bin.re"
			{ goto s_16; }
#line 2710 "<stdout>"
yy334:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy334;
			default:	goto yy336;
			}
yy336:
#line 624 "./txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_17; }
#line 2731 "<stdout>"
		}
#line 626 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_17:
    state = 17;
    // printf("Entered s_17\n");


#line 2743 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy341;
			case '\n':	goto yy344;
			case '\r':	goto yy346;
			case 'n':	goto yy347;
			default:	goto yy339;
			}
yy339:
			++YYCURSOR;
yy340:
#line 638 "./txt2bin.re"
			{ goto s_err; }
#line 2761 "<stdout>"
yy341:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy341;
			default:	goto yy343;
			}
yy343:
#line 635 "./txt2bin.re"
			{ goto s_17; }
#line 2774 "<stdout>"
yy344:
			++YYCURSOR;
#line 637 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2779 "<stdout>"
yy346:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy344;
			default:	goto yy340;
			}
yy347:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy348;
			default:	goto yy340;
			}
yy348:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy350;
			default:	goto yy349;
			}
yy349:
			YYCURSOR = YYMARKER;
			goto yy340;
yy350:
			++YYCURSOR;
#line 636 "./txt2bin.re"
			{ goto s_18; }
#line 2805 "<stdout>"
		}
#line 639 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_18:
    state = 18;
    // printf("Entered s_18\n");

    s->tok = cursor;


#line 2819 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy356;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy359;
			default:	goto yy354;
			}
yy354:
			++YYCURSOR;
#line 652 "./txt2bin.re"
			{ goto s_err; }
#line 2843 "<stdout>"
yy356:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy356;
			default:	goto yy358;
			}
yy358:
#line 650 "./txt2bin.re"
			{ goto s_18; }
#line 2856 "<stdout>"
yy359:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy359;
			default:	goto yy361;
			}
yy361:
#line 651 "./txt2bin.re"
			{ item.nic = add_number(s->tok, cursor); goto s_19; }
#line 2877 "<stdout>"
		}
#line 653 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_19:
    state = 19;
    // printf("Entered s_19\n");


#line 2889 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy366;
			case '\n':	goto yy369;
			case '\r':	goto yy371;
			default:	goto yy364;
			}
yy364:
			++YYCURSOR;
yy365:
#line 664 "./txt2bin.re"
			{ goto s_err; }
#line 2906 "<stdout>"
yy366:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy366;
			default:	goto yy368;
			}
yy368:
#line 662 "./txt2bin.re"
			{ goto s_19; }
#line 2919 "<stdout>"
yy369:
			++YYCURSOR;
#line 663 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2924 "<stdout>"
yy371:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy369;
			default:	goto yy365;
			}
		}
#line 665 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_20:
    state = 20;
    // printf("Entered s_20\n");

    s->tok = cursor;


#line 2944 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy376;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy379;
			default:	goto yy374;
			}
yy374:
			++YYCURSOR;
#line 678 "./txt2bin.re"
			{ goto s_err; }
#line 2968 "<stdout>"
yy376:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy376;
			default:	goto yy378;
			}
yy378:
#line 676 "./txt2bin.re"
			{ goto s_20; }
#line 2981 "<stdout>"
yy379:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy379;
			default:	goto yy381;
			}
yy381:
#line 677 "./txt2bin.re"
			{ s->rank = add_number(s->tok, cursor); s->curr_rank = s->rank; goto s_21; }
#line 3002 "<stdout>"
		}
#line 679 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_21:
    state = 21;
    // printf("Entered s_21\n");


#line 3014 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy386;
			case '{':	goto yy389;
			default:	goto yy384;
			}
yy384:
			++YYCURSOR;
#line 690 "./txt2bin.re"
			{ goto s_err; }
#line 3029 "<stdout>"
yy386:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy386;
			default:	goto yy388;
			}
yy388:
#line 688 "./txt2bin.re"
			{ goto s_21; }
#line 3042 "<stdout>"
yy389:
			++YYCURSOR;
#line 689 "./txt2bin.re"
			{ goto s_0; }
#line 3047 "<stdout>"
		}
#line 691 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_22:
    state = 22;
    // printf("Entered s_22\n");

    s->tok = cursor;


#line 3061 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy395;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy398;
			default:	goto yy393;
			}
yy393:
			++YYCURSOR;
#line 704 "./txt2bin.re"
			{ goto s_err; }
#line 3085 "<stdout>"
yy395:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy395;
			default:	goto yy397;
			}
yy397:
#line 702 "./txt2bin.re"
			{ goto s_22; }
#line 3098 "<stdout>"
yy398:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy398;
			default:	goto yy400;
			}
yy400:
#line 703 "./txt2bin.re"
			{ s->num_ranks = add_number(s->tok, cursor); goto s_0; }
#line 3119 "<stdout>"
		}
#line 705 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_23:
    state = 23;
    // printf("Entered s_23\n");


#line 3131 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy405;
			case '\r':	goto yy407;
			default:	goto yy403;
			}
yy403:
			++YYCURSOR;
yy404:
#line 715 "./txt2bin.re"
			{ goto s_23; }
#line 3146 "<stdout>"
yy405:
			++YYCURSOR;
#line 714 "./txt2bin.re"
			{ s->line++; continue;  }
#line 3151 "<stdout>"
yy407:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '\n':	goto yy405;
			default:	goto yy404;
			}
		}
#line 716 "./txt2bin.re"


    assert(0==1); //We should never reach this line

s_24:
    state = 24;
    // printf("Entered s_24\n");


#line 3169 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy412;
			case '\r':	goto yy414;
			case '*':	goto yy415;
			default:	goto yy410;
			}
yy410:
			++YYCURSOR;
yy411:
#line 727 "./txt2bin.re"
			{ goto s_24; }
#line 3185 "<stdout>"
yy412:
			++YYCURSOR;
#line 726 "./txt2bin.re"
			{ s->line++; goto s_24;  }
#line 3190 "<stdout>"
yy414:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy412;
			default:	goto yy411;
			}
yy415:
			yych = *++YYCURSOR;
			switch (yych) {
			case '/':	goto yy416;
			default:	goto yy411;
			}
yy416:
			++YYCURSOR;
#line 725 "./txt2bin.re"
			{ continue; }
#line 3207 "<stdout>"
		}
#line 728 "./txt2bin.re"


    assert(0==1); //We should never reach this line

/* Begin triggered operation parameters */
s_25:
    state = 25;


#line 3219 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy422;
			case 'w':	goto yy425;
			default:	goto yy420;
			}
yy420:
			++YYCURSOR;
yy421:
#line 739 "./txt2bin.re"
			{ goto s_err; }
#line 3235 "<stdout>"
yy422:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy422;
			default:	goto yy424;
			}
yy424:
#line 737 "./txt2bin.re"
			{ goto s_25; }
#line 3248 "<stdout>"
yy425:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'h':	goto yy426;
			default:	goto yy421;
			}
yy426:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy428;
			default:	goto yy427;
			}
yy427:
			YYCURSOR = YYMARKER;
			goto yy421;
yy428:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy429;
			default:	goto yy427;
			}
yy429:
			++YYCURSOR;
#line 738 "./txt2bin.re"
			{ goto s_26; }
#line 3274 "<stdout>"
		}
#line 740 "./txt2bin.re"


    assert(0==1);

s_26:
    state = 26;
    s->tok = cursor;

#line 3285 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy435;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy438;
			default:	goto yy433;
			}
yy433:
			++YYCURSOR;
#line 750 "./txt2bin.re"
			{ goto s_err; }
#line 3309 "<stdout>"
yy435:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy435;
			default:	goto yy437;
			}
yy437:
#line 748 "./txt2bin.re"
			{ goto s_26; }
#line 3322 "<stdout>"
yy438:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy438;
			default:	goto yy440;
			}
yy440:
#line 749 "./txt2bin.re"
			{ item.ct = add_number(s->tok, cursor); goto s_27; }
#line 3343 "<stdout>"
		}
#line 751 "./txt2bin.re"


    assert(0==1);

s_27:
    state = 27;


#line 3354 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy445;
			case 'r':	goto yy448;
			default:	goto yy443;
			}
yy443:
			++YYCURSOR;
yy444:
#line 761 "./txt2bin.re"
			{ goto s_err; }
#line 3370 "<stdout>"
yy445:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy445;
			default:	goto yy447;
			}
yy447:
#line 759 "./txt2bin.re"
			{ goto s_27; }
#line 3383 "<stdout>"
yy448:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy449;
			default:	goto yy444;
			}
yy449:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy451;
			default:	goto yy450;
			}
yy450:
			YYCURSOR = YYMARKER;
			goto yy444;
yy451:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy452;
			default:	goto yy450;
			}
yy452:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy453;
			default:	goto yy450;
			}
yy453:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy454;
			default:	goto yy450;
			}
yy454:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy455;
			default:	goto yy450;
			}
yy455:
			++YYCURSOR;
#line 760 "./txt2bin.re"
			{ goto s_28; }
#line 3427 "<stdout>"
		}
#line 762 "./txt2bin.re"


    assert(0==1);

s_28:
    state = 28;
    s->tok = cursor;

#line 3438 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy461;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy464;
			default:	goto yy459;
			}
yy459:
			++YYCURSOR;
#line 772 "./txt2bin.re"
			{ goto s_err; }
#line 3462 "<stdout>"
yy461:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy461;
			default:	goto yy463;
			}
yy463:
#line 770 "./txt2bin.re"
			{ goto s_28; }
#line 3475 "<stdout>"
yy464:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy464;
			default:	goto yy466;
			}
yy466:
#line 771 "./txt2bin.re"
			{ item.threshold = add_number(s->tok, cursor); if (item.type==tAppendOp) {goto s_34;} else {goto s_13;} }
#line 3496 "<stdout>"
		}
#line 773 "./txt2bin.re"


    assert(0==1);
/* End triggered ooeration parameters */

/* Begin Append/tAppend */
s_29:
    state=29;
    s->tok = cursor;

#line 3509 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy471;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy474;
			default:	goto yy469;
			}
yy469:
			++YYCURSOR;
#line 785 "./txt2bin.re"
			{ goto s_err; }
#line 3533 "<stdout>"
yy471:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy471;
			default:	goto yy473;
			}
yy473:
#line 783 "./txt2bin.re"
			{ goto s_29; }
#line 3546 "<stdout>"
yy474:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy474;
			default:	goto yy476;
			}
yy476:
#line 784 "./txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_38; }
#line 3567 "<stdout>"
		}
#line 786 "./txt2bin.re"



s_30:
    state=30;


#line 3577 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy481;
			case 't':	goto yy484;
			default:	goto yy479;
			}
yy479:
			++YYCURSOR;
yy480:
#line 795 "./txt2bin.re"
			{ goto s_err; }
#line 3593 "<stdout>"
yy481:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy481;
			default:	goto yy483;
			}
yy483:
#line 793 "./txt2bin.re"
			{ goto s_30; }
#line 3606 "<stdout>"
yy484:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy485;
			default:	goto yy480;
			}
yy485:
			++YYCURSOR;
#line 794 "./txt2bin.re"
			{ goto s_31; }
#line 3617 "<stdout>"
		}
#line 796 "./txt2bin.re"


s_31:
    state=31;

#line 3625 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy491;
			case 'o':	goto yy494;
			case 'p':	goto yy495;
			default:	goto yy489;
			}
yy489:
			++YYCURSOR;
yy490:
#line 804 "./txt2bin.re"
			{ goto s_err; }
#line 3642 "<stdout>"
yy491:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy491;
			default:	goto yy493;
			}
yy493:
#line 801 "./txt2bin.re"
			{ goto s_31; }
#line 3655 "<stdout>"
yy494:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'v':	goto yy496;
			default:	goto yy490;
			}
yy495:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy498;
			default:	goto yy490;
			}
yy496:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy499;
			default:	goto yy497;
			}
yy497:
			YYCURSOR = YYMARKER;
			goto yy490;
yy498:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy500;
			default:	goto yy497;
			}
yy499:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy501;
			default:	goto yy497;
			}
yy500:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy502;
			default:	goto yy497;
			}
yy501:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'f':	goto yy503;
			default:	goto yy497;
			}
yy502:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy504;
			default:	goto yy497;
			}
yy503:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy505;
			default:	goto yy497;
			}
yy504:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy506;
			default:	goto yy497;
			}
yy505:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy507;
			default:	goto yy497;
			}
yy506:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy508;
			default:	goto yy497;
			}
yy507:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy509;
			default:	goto yy497;
			}
yy508:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'y':	goto yy510;
			default:	goto yy497;
			}
yy509:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy511;
			default:	goto yy497;
			}
yy510:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy512;
			default:	goto yy497;
			}
yy511:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy513;
			default:	goto yy497;
			}
yy512:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy514;
			default:	goto yy497;
			}
yy513:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy515;
			default:	goto yy497;
			}
yy514:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy516;
			default:	goto yy497;
			}
yy515:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy517;
			default:	goto yy497;
			}
yy516:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy518;
			default:	goto yy497;
			}
yy517:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy519;
			default:	goto yy497;
			}
yy518:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy521;
			default:	goto yy497;
			}
yy519:
			++YYCURSOR;
#line 802 "./txt2bin.re"
			{ item.options |= OPT_OVERFLOW_LIST; goto s_32; }
#line 3807 "<stdout>"
yy521:
			++YYCURSOR;
#line 803 "./txt2bin.re"
			{ item.options |= OPT_PRIORITY_LIST; goto s_32; }
#line 3812 "<stdout>"
		}
#line 805 "./txt2bin.re"


s_32:
    state=32;

#line 3820 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy527;
			case 'a':	goto yy530;
			case 'c':	goto yy531;
			case 'h':	goto yy532;
			case 'm':	goto yy533;
			case 'p':	goto yy534;
			default:	goto yy525;
			}
yy525:
			++YYCURSOR;
yy526:
#line 820 "./txt2bin.re"
			{ goto s_err; }
#line 3840 "<stdout>"
yy527:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy527;
			default:	goto yy529;
			}
yy529:
#line 810 "./txt2bin.re"
			{ goto s_32; }
#line 3853 "<stdout>"
yy530:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'l':	goto yy535;
			case 'r':	goto yy537;
			default:	goto yy526;
			}
yy531:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy538;
			default:	goto yy526;
			}
yy532:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy540;
			default:	goto yy526;
			}
yy533:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy542;
			default:	goto yy526;
			}
yy534:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':	goto yy543;
			default:	goto yy526;
			}
yy535:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy545;
			default:	goto yy536;
			}
yy536:
			YYCURSOR = YYMARKER;
			goto yy526;
yy537:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy546;
			default:	goto yy536;
			}
yy538:
			++YYCURSOR;
#line 813 "./txt2bin.re"
			{ goto s_43; }
#line 3904 "<stdout>"
yy540:
			++YYCURSOR;
#line 811 "./txt2bin.re"
			{ goto s_41; }
#line 3909 "<stdout>"
yy542:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy547;
			default:	goto yy536;
			}
yy543:
			++YYCURSOR;
#line 812 "./txt2bin.re"
			{ goto s_42; }
#line 3920 "<stdout>"
yy545:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy549;
			default:	goto yy536;
			}
yy546:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy550;
			case '2':	goto yy552;
			case '3':	goto yy554;
			case '4':	goto yy556;
			default:	goto yy536;
			}
yy547:
			++YYCURSOR;
#line 814 "./txt2bin.re"
			{ goto s_44; }
#line 3940 "<stdout>"
yy549:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'w':	goto yy558;
			default:	goto yy536;
			}
yy550:
			++YYCURSOR;
#line 816 "./txt2bin.re"
			{ goto s_48; }
#line 3951 "<stdout>"
yy552:
			++YYCURSOR;
#line 817 "./txt2bin.re"
			{ goto s_49; }
#line 3956 "<stdout>"
yy554:
			++YYCURSOR;
#line 818 "./txt2bin.re"
			{ goto s_50; }
#line 3961 "<stdout>"
yy556:
			++YYCURSOR;
#line 819 "./txt2bin.re"
			{ goto s_51; }
#line 3966 "<stdout>"
yy558:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy559;
			default:	goto yy536;
			}
yy559:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy560;
			default:	goto yy536;
			}
yy560:
			++YYCURSOR;
#line 815 "./txt2bin.re"
			{ goto s_33; }
#line 3983 "<stdout>"
		}
#line 821 "./txt2bin.re"


s_33:
    state=33;
    s->tok = cursor;

#line 3992 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy566;
			case '-':	goto yy569;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy570;
			default:	goto yy564;
			}
yy564:
			++YYCURSOR;
yy565:
#line 830 "./txt2bin.re"
			{ goto s_err; }
#line 4018 "<stdout>"
yy566:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy566;
			default:	goto yy568;
			}
yy568:
#line 827 "./txt2bin.re"
			{ goto s_33; }
#line 4031 "<stdout>"
yy569:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy573;
			default:	goto yy565;
			}
yy570:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy570;
			default:	goto yy572;
			}
yy572:
#line 828 "./txt2bin.re"
			{ item.target = add_number(s->tok, cursor); if (item.type == tAppendOp)  { goto s_25; } else {goto s_13;} }
#line 4058 "<stdout>"
yy573:
			++YYCURSOR;
#line 829 "./txt2bin.re"
			{ item.target = std::numeric_limits<uint32_t>::max(); if (item.type == tAppendOp)  { goto s_25; } else {goto s_13;} }
#line 4063 "<stdout>"
		}
#line 831 "./txt2bin.re"


s_34:
    state=34;


#line 4072 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy579;
			case '\n':	goto yy582;
			case '\r':	goto yy584;
			case 'c':	goto yy585;
			case 'n':	goto yy586;
			case 't':	goto yy587;
			case 'u':	goto yy588;
			default:	goto yy577;
			}
yy577:
			++YYCURSOR;
yy578:
#line 843 "./txt2bin.re"
			{ goto s_err; }
#line 4093 "<stdout>"
yy579:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy579;
			default:	goto yy581;
			}
yy581:
#line 837 "./txt2bin.re"
			{ goto s_34; }
#line 4106 "<stdout>"
yy582:
			++YYCURSOR;
#line 842 "./txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 4111 "<stdout>"
yy584:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy582;
			default:	goto yy578;
			}
yy585:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy589;
			default:	goto yy578;
			}
yy586:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy591;
			default:	goto yy578;
			}
yy587:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy592;
			default:	goto yy578;
			}
yy588:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 's':	goto yy593;
			default:	goto yy578;
			}
yy589:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy594;
			default:	goto yy590;
			}
yy590:
			YYCURSOR = YYMARKER;
			goto yy578;
yy591:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy596;
			default:	goto yy590;
			}
yy592:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy598;
			default:	goto yy590;
			}
yy593:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy600;
			default:	goto yy590;
			}
yy594:
			++YYCURSOR;
#line 840 "./txt2bin.re"
			{ goto s_16; }
#line 4173 "<stdout>"
yy596:
			++YYCURSOR;
#line 841 "./txt2bin.re"
			{ goto s_18; }
#line 4178 "<stdout>"
yy598:
			++YYCURSOR;
#line 839 "./txt2bin.re"
			{ goto s_14; }
#line 4183 "<stdout>"
yy600:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy601;
			default:	goto yy590;
			}
yy601:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy602;
			default:	goto yy590;
			}
yy602:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy603;
			default:	goto yy590;
			}
yy603:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy604;
			default:	goto yy590;
			}
yy604:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy605;
			default:	goto yy590;
			}
yy605:
			++YYCURSOR;
#line 838 "./txt2bin.re"
			{ item.options |= OPT_USE_ONCE; goto s_13; }
#line 4218 "<stdout>"
		}
#line 844 "./txt2bin.re"

/* End Append/tAppend */

/* Begin CTWait */
s_35:
    state=35;
    s->tok = cursor;

#line 4229 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy611;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy614;
			default:	goto yy609;
			}
yy609:
			++YYCURSOR;
#line 854 "./txt2bin.re"
			{ goto s_err; }
#line 4253 "<stdout>"
yy611:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy611;
			default:	goto yy613;
			}
yy613:
#line 852 "./txt2bin.re"
			{ goto s_35; }
#line 4266 "<stdout>"
yy614:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy614;
			default:	goto yy616;
			}
yy616:
#line 853 "./txt2bin.re"
			{ item.ct = add_number(s->tok, cursor); goto s_36; }
#line 4287 "<stdout>"
		}
#line 855 "./txt2bin.re"


s_36:
    state=36;


#line 4296 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy621;
			case 'f':	goto yy624;
			default:	goto yy619;
			}
yy619:
			++YYCURSOR;
yy620:
#line 863 "./txt2bin.re"
			{ goto s_err; }
#line 4312 "<stdout>"
yy621:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy621;
			default:	goto yy623;
			}
yy623:
#line 861 "./txt2bin.re"
			{ goto s_36; }
#line 4325 "<stdout>"
yy624:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'o':	goto yy625;
			default:	goto yy620;
			}
yy625:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy627;
			default:	goto yy626;
			}
yy626:
			YYCURSOR = YYMARKER;
			goto yy620;
yy627:
			++YYCURSOR;
#line 862 "./txt2bin.re"
			{ goto s_37; }
#line 4345 "<stdout>"
		}
#line 864 "./txt2bin.re"


s_37:
    state=37;
    s->tok = cursor;

#line 4354 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy633;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy636;
			default:	goto yy631;
			}
yy631:
			++YYCURSOR;
#line 872 "./txt2bin.re"
			{ goto s_err; }
#line 4378 "<stdout>"
yy633:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy633;
			default:	goto yy635;
			}
yy635:
#line 870 "./txt2bin.re"
			{ goto s_37; }
#line 4391 "<stdout>"
yy636:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy636;
			default:	goto yy638;
			}
yy638:
#line 871 "./txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 4412 "<stdout>"
		}
#line 873 "./txt2bin.re"


/* End CTWait */

//I forgot it in the append...
s_38:
    state=38;
    // printf("Entered s_10\n");


#line 4425 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy643;
			case 'b':	goto yy646;
			default:	goto yy641;
			}
yy641:
			++YYCURSOR;
#line 885 "./txt2bin.re"
			{ goto s_err; }
#line 4440 "<stdout>"
yy643:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy643;
			default:	goto yy645;
			}
yy645:
#line 883 "./txt2bin.re"
			{ goto s_38; }
#line 4453 "<stdout>"
yy646:
			++YYCURSOR;
#line 884 "./txt2bin.re"
			{ goto s_30; }
#line 4458 "<stdout>"
		}
#line 886 "./txt2bin.re"


/* Read CT param */
s_39:
    state=39;


#line 4468 "<stdout>"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy652;
			case 'c':	goto yy655;
			default:	goto yy650;
			}
yy650:
			++YYCURSOR;
yy651:
#line 895 "./txt2bin.re"
			{ goto s_err; }
#line 4484 "<stdout>"
yy652:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy652;
			default:	goto yy654;
			}
yy654:
#line 893 "./txt2bin.re"
			{ goto s_39; }
#line 4497 "<stdout>"
yy655:
			yych = *++YYCURSOR;
			switch (yych) {
			case 't':	goto yy656;
			default:	goto yy651;
			}
yy656:
			++YYCURSOR;
#line 894 "./txt2bin.re"
			{ goto s_40; }
#line 4508 "<stdout>"
		}
#line 896 "./txt2bin.re"


s_40:
    state=40;
    s->tok = cursor;

#line 4517 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy662;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy665;
			default:	goto yy660;
			}
yy660:
			++YYCURSOR;
#line 904 "./txt2bin.re"
			{ goto s_err; }
#line 4541 "<stdout>"
yy662:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy662;
			default:	goto yy664;
			}
yy664:
#line 902 "./txt2bin.re"
			{ goto s_40; }
#line 4554 "<stdout>"
yy665:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy665;
			default:	goto yy667;
			}
yy667:
#line 903 "./txt2bin.re"
			{ item.oct = add_number(s->tok, cursor); if (item.type==AppendOp || item.type==tAppendOp) { goto s_34;} else {goto s_13;} }
#line 4575 "<stdout>"
		}
#line 905 "./txt2bin.re"




/* Handlers for append/tappend */
s_41:
    state=41;
    s->tok = cursor;

#line 4587 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy672;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy675;
			default:	goto yy670;
			}
yy670:
			++YYCURSOR;
#line 916 "./txt2bin.re"
			{ goto s_err; }
#line 4611 "<stdout>"
yy672:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy672;
			default:	goto yy674;
			}
yy674:
#line 914 "./txt2bin.re"
			{ goto s_41; }
#line 4624 "<stdout>"
yy675:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy675;
			default:	goto yy677;
			}
yy677:
#line 915 "./txt2bin.re"
			{ item.hh = add_number(s->tok, cursor); goto  s_32; }
#line 4645 "<stdout>"
		}
#line 917 "./txt2bin.re"


s_42:
    state=42;
    s->tok = cursor;

#line 4654 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy682;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy685;
			default:	goto yy680;
			}
yy680:
			++YYCURSOR;
#line 925 "./txt2bin.re"
			{ goto s_err; }
#line 4678 "<stdout>"
yy682:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy682;
			default:	goto yy684;
			}
yy684:
#line 923 "./txt2bin.re"
			{ goto s_42; }
#line 4691 "<stdout>"
yy685:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy685;
			default:	goto yy687;
			}
yy687:
#line 924 "./txt2bin.re"
			{ item.ph = add_number(s->tok, cursor); goto  s_32; }
#line 4712 "<stdout>"
		}
#line 926 "./txt2bin.re"


s_43:
    state=43;
    s->tok = cursor;

#line 4721 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy692;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy695;
			default:	goto yy690;
			}
yy690:
			++YYCURSOR;
#line 934 "./txt2bin.re"
			{ goto s_err; }
#line 4745 "<stdout>"
yy692:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy692;
			default:	goto yy694;
			}
yy694:
#line 932 "./txt2bin.re"
			{ goto s_43; }
#line 4758 "<stdout>"
yy695:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy695;
			default:	goto yy697;
			}
yy697:
#line 933 "./txt2bin.re"
			{ item.ch = add_number(s->tok, cursor); goto  s_32; }
#line 4779 "<stdout>"
		}
#line 935 "./txt2bin.re"


s_44:
    state=44;
    s->tok = cursor;

#line 4788 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy702;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy705;
			default:	goto yy700;
			}
yy700:
			++YYCURSOR;
#line 943 "./txt2bin.re"
			{ goto s_err; }
#line 4812 "<stdout>"
yy702:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy702;
			default:	goto yy704;
			}
yy704:
#line 941 "./txt2bin.re"
			{ goto s_44; }
#line 4825 "<stdout>"
yy705:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy705;
			default:	goto yy707;
			}
yy707:
#line 942 "./txt2bin.re"
			{ item.mem = add_number(s->tok, cursor); goto  s_32; }
#line 4846 "<stdout>"
		}
#line 944 "./txt2bin.re"


/* for calcgem5 */
s_45:
    state=45;
    s->tok = cursor;

#line 4856 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy712;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy715;
			default:	goto yy710;
			}
yy710:
			++YYCURSOR;
#line 953 "./txt2bin.re"
			{ goto s_err; }
#line 4880 "<stdout>"
yy712:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy712;
			default:	goto yy714;
			}
yy714:
#line 951 "./txt2bin.re"
			{ goto s_45; }
#line 4893 "<stdout>"
yy715:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy715;
			default:	goto yy717;
			}
yy717:
#line 952 "./txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_46; }
#line 4914 "<stdout>"
		}
#line 954 "./txt2bin.re"


s_46:
    state=46;
    s->tok = cursor;

#line 4923 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy722;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy725;
			default:	goto yy720;
			}
yy720:
			++YYCURSOR;
#line 962 "./txt2bin.re"
			{ goto s_err; }
#line 4947 "<stdout>"
yy722:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy722;
			default:	goto yy724;
			}
yy724:
#line 960 "./txt2bin.re"
			{ goto s_46; }
#line 4960 "<stdout>"
yy725:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy725;
			default:	goto yy727;
			}
yy727:
#line 961 "./txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_47; }
#line 4981 "<stdout>"
		}
#line 963 "./txt2bin.re"


s_47:
    state=47;

#line 4989 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy732;
			case 'b':	goto yy735;
			default:	goto yy730;
			}
yy730:
			++YYCURSOR;
#line 970 "./txt2bin.re"
			{ goto s_err; }
#line 5004 "<stdout>"
yy732:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy732;
			default:	goto yy734;
			}
yy734:
#line 968 "./txt2bin.re"
			{ goto s_47; }
#line 5017 "<stdout>"
yy735:
			++YYCURSOR;
#line 969 "./txt2bin.re"
			{goto s_7;}
#line 5022 "<stdout>"
		}
#line 971 "./txt2bin.re"



s_48:
    s->tok = cursor;
    state=48;

#line 5032 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy741;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy744;
			default:	goto yy739;
			}
yy739:
			++YYCURSOR;
#line 980 "./txt2bin.re"
			{ goto s_err; }
#line 5056 "<stdout>"
yy741:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy741;
			default:	goto yy743;
			}
yy743:
#line 978 "./txt2bin.re"
			{ goto s_48; }
#line 5069 "<stdout>"
yy744:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy744;
			default:	goto yy746;
			}
yy746:
#line 979 "./txt2bin.re"
			{ item.arg[0] = add_number(s->tok, cursor); if (item.type == PutOp|| item.type == tPutOp) {goto s_11;} else {goto s_32;} }
#line 5090 "<stdout>"
		}
#line 981 "./txt2bin.re"


s_49:
    s->tok = cursor;
    state=49;

#line 5099 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy751;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy754;
			default:	goto yy749;
			}
yy749:
			++YYCURSOR;
#line 989 "./txt2bin.re"
			{ goto s_err; }
#line 5123 "<stdout>"
yy751:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy751;
			default:	goto yy753;
			}
yy753:
#line 987 "./txt2bin.re"
			{ goto s_49; }
#line 5136 "<stdout>"
yy754:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy754;
			default:	goto yy756;
			}
yy756:
#line 988 "./txt2bin.re"
			{ item.arg[1] = add_number(s->tok, cursor); if (item.type == PutOp|| item.type == tPutOp) {goto s_11;} else {goto s_32;} }
#line 5157 "<stdout>"
		}
#line 990 "./txt2bin.re"


s_50:
    s->tok = cursor;
    state=50;

#line 5166 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy761;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy764;
			default:	goto yy759;
			}
yy759:
			++YYCURSOR;
#line 998 "./txt2bin.re"
			{ goto s_err; }
#line 5190 "<stdout>"
yy761:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy761;
			default:	goto yy763;
			}
yy763:
#line 996 "./txt2bin.re"
			{ goto s_50; }
#line 5203 "<stdout>"
yy764:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy764;
			default:	goto yy766;
			}
yy766:
#line 997 "./txt2bin.re"
			{ item.arg[2] = add_number(s->tok, cursor);  if (item.type == PutOp|| item.type == tPutOp) {goto s_11;} else {goto s_32;} }
#line 5224 "<stdout>"
		}
#line 999 "./txt2bin.re"


s_51:
    s->tok = cursor;
    state=51;

#line 5233 "<stdout>"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy771;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy774;
			default:	goto yy769;
			}
yy769:
			++YYCURSOR;
#line 1007 "./txt2bin.re"
			{ goto s_err; }
#line 5257 "<stdout>"
yy771:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy771;
			default:	goto yy773;
			}
yy773:
#line 1005 "./txt2bin.re"
			{ goto s_51; }
#line 5270 "<stdout>"
yy774:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy774;
			default:	goto yy776;
			}
yy776:
#line 1006 "./txt2bin.re"
			{ item.arg[3] = add_number(s->tok, cursor);  if (item.type == PutOp|| item.type == tPutOp) {goto s_11;} else {goto s_32;}}
#line 5291 "<stdout>"
		}
#line 1008 "./txt2bin.re"

s_err:

    fprintf(stderr, "Error in line %i:\n", s->line);

    uchar* nlbef = s->bot;
    uchar* nlaft = s->lim;
    // find the last newline before the error
    uchar* c = cursor-2;
    while (c>s->bot) {
        c--;
        if (*c == '\n') {
            nlbef = c;
            break;
        }
    }
    // find the next newline after the error
    c = cursor-2;
    while (c<s->lim) {
        c++;
        if (*c == '\n') {
            nlaft = c;
            break;
        }
    }

    for (uchar* c = nlbef+1; c<nlaft; c++) {
        fprintf(stderr, "%c", *c);
    }
    fprintf(stderr, "\n");

    for (int cnt=0; cnt<(cursor-2)-nlbef; cnt++) {
        fprintf(stderr, " ");
    }
    fprintf(stderr, "^\n");


    switch(state) {
        case 0:
            fprintf(stderr,"Expected: \"rank\", \"num_ranks\", \"calc\", \"send\", \"recv\", an identifier, \"}\" or \"\\n\"\n");
            break;
        case 1:
            fprintf(stderr,"Expected: \":\", \"requires\" or \"irequires\"\n");
            break;
        case 2:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 3:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 4:
            fprintf(stderr,"Expected: \"calc\", \"send\" or \"recv\"\n");
            break;
        case 5:
            fprintf(stderr,"Expected: an identifier\n");
            break;
        case 6:
            fprintf(stderr,"Expected: \"\\n\"\n");
            break;
        case 7:
            fprintf(stderr,"Expected: \"cpu\" or \"\\n\"\n");
            break;
        case 8:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 9:
            fprintf(stderr,"Expected: \"\\n\"\n");
            break;
        case 10:
            fprintf(stderr,"Expected: \"b\"\n");
            break;
        case 11:
            if (item.type == SendOp) fprintf(stderr,"Expected: \"to\"\n");
            else if (item.type == RecvOp) fprintf(stderr,"Expected: \"from\"\n");
            else fprintf(stderr,"Expected: \"to\" or \"from\"\n");
            break;
        case 12:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 13:
            fprintf(stderr,"Expected: \"tag\", \"cpu\", \"nic\" or \"\\n\"\n");
            break;
        case 14:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 15:
            fprintf(stderr,"Expected: \"cpu\", \"nic\" or \"\\n\"\n");
            break;
        case 16:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 17:
            fprintf(stderr,"Expected: \"nic\" or \"\\n\"\n");
            break;
        case 18:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 19:
            fprintf(stderr,"Expected: \"\\n\"\n");
            break;
        case 20:
            fprintf(stderr,"Expected: an integer\n");
            break;
        case 21:
            fprintf(stderr,"Expected: \"{\"\n");
            break;
        case 22:
            fprintf(stderr,"Expected: an integer\n");
            break;
    }

    if (*(cursor-1) == '\n') {
        fprintf(stderr, "Instead the schedule contained: \"\\n\"\n");
    }
    else {
        fprintf(stderr, "Instead the schedule contained: \"%c\"\n", *(cursor-1));
    }



    exit(EXIT_FAILURE);

}
}

main(int argc, char **argv){

    Scanner in;
    int lastprogress = 0;

    if (cmdline_parser(argc, argv, &args_info) != 0) {
        fprintf(stderr, "Couldn't parse command line arguments!\n");
        exit(EXIT_FAILURE);
    }

    memset((char*) &in, 0, sizeof(in));
    in.fd = fopen(args_info.input_arg, "r");
    if (in.fd == NULL) {
        fprintf(stderr, "Couldn't open input file %s!\n", args_info.input_arg);
        exit(EXIT_FAILURE);
    }
    in.idtbl = new std::map<std::string, goalop_t>;

    uint32_t numranks = -1;

    while (true) {

        in.schedule = new Goal;

        scan(&in);

        if (in.num_ranks < 1) {
            fprintf(stderr, "Parse error: Number of Ranks undefined\n");
            exit(EXIT_FAILURE);
        }

        in.idtbl->clear();

        in.schedule->SetRank(in.curr_rank);
        in.schedule->SetNumRanks(in.num_ranks);
        in.schedule->SerializeSchedule(args_info.output_arg);
        delete in.schedule;
        int newprogress = round((((double) in.curr_rank) / in.num_ranks)*100);
        if (args_info.progress_given && (newprogress > lastprogress) ) {
            lastprogress = newprogress;
            printf("Progress %i%% - parsed schedule %i/%i\n", lastprogress, in.curr_rank, in.num_ranks);
        }
        if (in.curr_rank+1 == in.num_ranks) break;
    }

    free(in.bot);
    exit(EXIT_SUCCESS);
}

