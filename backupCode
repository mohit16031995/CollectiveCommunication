#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <mpi.h>

#define max_processors 1000

struct TreeNode* leftTreeNode[max_processors];
struct TreeNode* rightTreeNode[max_processors];


void printGivenLevel(struct TreeNode* root, int level);
int height(struct TreeNode* node);
void printLevelOrder(struct TreeNode* root);
struct TreeNode* newNode(int data, int tree);
struct TreeNode* constructleft(int start_id, int last_id);
struct TreeNode* constructTree(int no_of_pe, int start_id);
void traverse(struct TreeNode* root);
struct TreeNode* mirror(struct TreeNode* root, int no_of_pe);
struct TreeNode* addNode (int node_id, struct TreeNode* root, int tree);
void addParentColor(int node_id, int tree, int color);

struct TreeNode
{
    int process_id;
    struct TreeNode *left_child;
    int leftColor, rightColor;
    struct TreeNode* parent;
    struct TreeNode *right_child;
};

void printLevelOrder(struct TreeNode* root)
{
    int h = height(root);
    int i;
    for (i=1; i<=h; i++)
        printGivenLevel(root, i);
}

/* Print nodes at a given level */
void printGivenLevel(struct TreeNode* root, int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        printf("%d ", root->process_id);
    else if (level > 1)
    {
        printGivenLevel(root->left_child, level-1);
        printGivenLevel(root->right_child, level-1);
    }
}

/* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct TreeNode* node)
{
    if (node==NULL)
        return 0;
    else
    {
        /* compute the height of each subtree */
        int lheight = height(node->left_child);
        int rheight = height(node->right_child);

        /* use the larger one */
        if (lheight > rheight)
            return(lheight+1);
        else return(rheight+1);
    }
}

struct TreeNode* newNode(int data, int tree)
{
  struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
  node->process_id = data;
  node->left_child = NULL;
  node->right_child = NULL;
  node->leftColor = -1;
  node->rightColor = -1;
  if (tree == 0) {
    leftTreeNode[data] = node;
  }
  else {
    rightTreeNode[data] = node;
  }
  return(node);
}

struct TreeNode* constructleft(int start_id, int last_id) {
    if (start_id < last_id) {
    int mid = ceil((start_id+last_id) / 2);
    struct TreeNode* root = newNode(mid,0);
    root->left_child = constructleft(start_id, mid-1);
    if (root->left_child != NULL)
        root->left_child->parent = root;
    root->right_child = constructleft(mid+1, last_id);
    if (root->right_child != NULL)
        root->right_child->parent = root;

    return root;
    }
    else if (start_id == last_id) {
        return newNode(start_id,0);
    }
    else {
        return NULL;
    }
}
struct TreeNode* constructTree(int no_of_pe, int start_id) {
    //printf("construct %d %d \n" , no_of_pe, start_id);
    if (no_of_pe <= 0) {
        return NULL;
    }
    if (no_of_pe == 1) {
        return newNode(start_id,0);
    }
    int h = ceil((log10(no_of_pe+2.0)) / log10(2.0));
    int root_id = pow(2,h-1)-1 + start_id;
    struct TreeNode* root = newNode(root_id,0);
    //printf("%d", root->process_id);
    root->left_child = constructleft(start_id, root_id-1);
    if (root->left_child != NULL)
        root->left_child->parent = root;
    root->right_child = constructTree(no_of_pe-root_id, root_id+1);
    if (root->right_child != NULL)
        root->right_child->parent = root;
    return root;
}
void traverse(struct TreeNode* root) {
   if (root == NULL) {
    return;
   }
   printf("%d ", root->process_id);
   traverse(root->left_child);
   traverse(root->right_child);
}
struct TreeNode* mirror(struct TreeNode* root, int no_of_pe) {
    if (root == NULL) {
        return NULL;
    }
    struct TreeNode* temp = newNode(no_of_pe - root->process_id+1,1);
    temp->left_child = mirror(root->left_child, no_of_pe);
    if (temp->left_child != NULL)
        temp->left_child->parent = temp;
    temp->right_child = mirror(root->right_child, no_of_pe);
    if (temp->right_child != NULL)
        temp->right_child->parent = temp;

    return temp;
}
struct TreeNode* addNode (int node_id, struct TreeNode* root, int tree) {
    struct TreeNode* node = newNode(node_id, tree);
    node->left_child = root;
}
void addParentColor(int node_id, int tree, int color) {
    //printf("addColor : %d, %d %d\n", node_id, tree, color);
    struct TreeNode* node;
    if (tree == 0) {
        node = leftTreeNode[node_id];
    }
    else {
        node = rightTreeNode[node_id];
    }
    struct TreeNode* parentNode = node->parent;
    if (parentNode == NULL) {
        //printf("%d ka parent null hai\n", node_id);
        return;
    }
    if (parentNode->left_child == node) {
        printf("left child hai, ");
        parentNode->leftColor = color;
        if (parentNode->right_child != NULL) {
            //printf("right child %d hai\n", parentNode->right_child->process_id);
            parentNode->rightColor = !(color);
            addParentColor(parentNode->right_child->process_id, !tree, color);
        }
    }
    else if (parentNode->right_child == node){
        //printf("right child hai, ");
        parentNode->rightColor = color;
        if (parentNode->left_child != NULL) {
            //printf("left child %d hai\n", parentNode->left_child->process_id);
            parentNode->leftColor = !color;
            addParentColor(parentNode->left_child->process_id, !tree, color);
        }
    }
}
int main(int argc, char *argv[]) {
    int total_process, no_of_process;
    total_process = atoi(argv[1]);
	no_of_process = total_process - 1;
    struct TreeNode* root, *root2;
    int h = ceil((log10(no_of_process+2)) / log10(2.0));
    if (no_of_process == pow(2,h) - 2) {
        root = constructleft(1, no_of_process);
        root2 = mirror(root, no_of_process);
    }
    if (no_of_process == pow(2,h)-1) {
        root = constructleft(1, no_of_process-1);
        root2 = mirror(root, no_of_process-1);
        struct TreeNode* temp = newNode(no_of_process-1,0);
        temp->left_child = root;
        root = temp;
        struct TreeNode* temp2 = newNode(no_of_process-1,1);
        temp2->left_child = root2;
        root2 = temp2;
    }
    else if (no_of_process % 2 == 0) {
        root = constructTree(no_of_process, 1);
        root->parent = NULL;
        root2 = mirror(root, no_of_process);
        root2->parent = NULL;
    }
    else {
        root = constructTree(no_of_process-1, 1);
        root->parent = NULL;
        root2 = mirror(root, no_of_process-1);
        root2->parent = NULL;
        addNode(no_of_process, root, 0);
        addNode(no_of_process, root2, 1);

    }
    printf("Constructed \n");
	struct TreeNode* top_node = (struct TreeNode*)malloc(sizeof(struct TreeNode));
	top_node->process_id = 0;
	top_node->left_child = root;
	top_node->right_child = root2;
	root->parent = top_node;
	root2->parent = top_node;

    	printLevelOrder(root);
    	printf("\n");
    	printLevelOrder(root2);
    	printf("\n");
	printLevelOrder(top_node);
	printf("\n");
		
	top_node->leftColor = 0;
	addParentColor(root->process_id, 1, 1);
	top_node->rightColor = 1;
	addParentColor(root2->process_id, 0, 0);
    if (root->leftColor == -1 && root->rightColor == -1) {
        if (root->left_child != NULL) {
            root->leftColor = 0;
            addParentColor(root->left_child->process_id, 1, 1);
        }
        if (root->right_child != NULL) {
            root->rightColor = 1;
            addParentColor(root->right_child->process_id, 1, 0);
        }
    }
    if (root2->leftColor == -1 && root2->rightColor == -1) {
        if (root2->left_child != NULL) {
            root2->leftColor = 0;
            addParentColor(root2->left_child->process_id, 0, 1);
        }
        if (root2->right_child != NULL) {
            root2->rightColor = 1;
            addParentColor(root2->right_child->process_id, 0, 0);
        }
    }
   // printf("Colored\n");
    for (int i = 1; i <= no_of_process; i++) {
      	 printf("process_id = %d : \n", i);
        struct TreeNode* temp1 = leftTreeNode[i];
        struct TreeNode* temp2 = rightTreeNode[i];

        printf("Tree1 : parent = %d, leftColor = %d, rightColor = %d\n", temp1->parent->process_id, temp1->leftColor, temp1->rightColor);
        printf("Tree2 : parent = %d, leftColor = %d, rightColor = %d\n\n", temp2->parent->process_id, temp2->leftColor, temp2->rightColor);
    }

//	printf("argc = %d\n, argv[0] = %s\n, argv[1] = %s\n, argv[2] = %s\n", argc, argv[0], argv[1], argv[2]);
	
		
/*	
    // RUN MPI
    int rank,p,index,cdone=0;
    long int sent,i,j,SIZE,CSIZE;
	char *ptr;

	int CHUNK;

    int seed = time(NULL);
	srand(seed);
	//char inmsg[SIZE], outmsg[SIZE];
	printf("point0\n");
	MPI_Init(&argc,&argv);
	printf("point0.2\n");
	MPI_Comm_size(MPI_COMM_WORLD, &p);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	
	printf ("point1\n");
	if(argc!=4){
	  if(rank==0) printf("Usage: <program> <message_size> <nchunk>\n");
		printf("error due to input\n");
	  exit(0);
	}

	SIZE = strtol(argv[2], &ptr, 10);
	CHUNK = atoi(argv[3]);
	CSIZE = SIZE/CHUNK;
	SIZE = CSIZE*CHUNK;

	char *msg = malloc(SIZE+1 * sizeof(char));
	char *outmsg = malloc(SIZE+1 * sizeof(char));

	// for recvs
	MPI_Status stt;
	MPI_Request req[CHUNK];

	// for send
	MPI_Status sstt[CHUNK*2];
	MPI_Request sreq[CHUNK*2];

	double t1,t2,res;

	for(i=0;i<SIZE;i++) {
		outmsg[i] = 'A'+rand()%26;
		if(rank==0) msg[i] = outmsg[i];
	}
	outmsg[SIZE] = '\0';
	msg[SIZE] = '\0';

//	printf("point2\n");
    int RUNS = 10;
    for(i=0;i<RUNS;i++){
		MPI_Barrier(MPI_COMM_WORLD);
		
		t1 = MPI_Wtime();

        sent = 0;
        if (rank == 0){  // if root then setup all send's
            for(j=0;j<CHUNK;j++) {
			// left tree
                if(!(j%2)) {
                    MPI_Isend(outmsg+j*CSIZE,CSIZE,MPI_CHAR, root->process_id,j,MPI_COMM_WORLD, &sreq[sent++]);
			
                }
			// right tree
                else {
                    MPI_Isend(outmsg+j*CSIZE,CSIZE,MPI_CHAR,root2->process_id,j,MPI_COMM_WORLD, &sreq[sent++]);
			
                }
            }
	}
        if(rank!=0) {// if not root setup all recvs
	
		MPI_Irecv(msg, CSIZE, MPI_CHAR, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &req[0]);
		MPI_Irecv(msg+CSIZE, CSIZE, MPI_CHAR, MPI_ANY_SOURCE, 1, MPI_COMM_WORLD, &req[1]);
            	printf("Wait: rank = %d\n", rank);
		MPI_Waitany(2, req, &index, &stt);
            if(index == MPI_UNDEFINED) {
                printf("Unexpected error!\n");
                MPI_Abort(MPI_COMM_WORLD, 1);
            }
		printf("Recieved: Process id %d wait over recv %d chunk\n", rank, stt.MPI_TAG);
            int turn;
            int leftrecvd = -2;
            int rightrecvd = -1;
		int leftsent = 0;
		int rightsent = 0;
            if (index == 0) {
                leftrecvd = 0;
                struct TreeNode* temp = leftTreeNode[rank];
                if (temp->parent->left_child == temp) {
                    turn = temp->parent->leftColor;
                }
                else {
                    turn = temp->parent->rightColor;
                }
            }
            else if (index == 1) {
                rightrecvd = 1;
                struct TreeNode* temp = rightTreeNode[rank];
                if (temp->parent->left_child == temp) {
                    turn = temp->parent->leftColor;
                }
                else {
                    turn = temp->parent->rightColor;
                }
            }
            else {
                printf("error\n");
            }
            int recieved = 1;
            
		
            //count no of childs
            int no_of_childs = 0;
		int leftTreeChilds = 0;
		int rightTreeChilds = 0;
            struct TreeNode* t1 = leftTreeNode[rank];
            if (t1->left_child != NULL) {
                no_of_childs += 1;
		leftTreeChilds += 1;
            }
            if (t1->right_child != NULL) {
                no_of_childs += 1;
		leftTreeChilds += 1;
            }
            t1 = rightTreeNode[rank];
            if (t1->left_child != NULL) {
                no_of_childs += 1;
		rightTreeChilds += 1;
            }
            if (t1->right_child != NULL) {
                no_of_childs += 1;
		rightTreeChilds += 1;
            }
	
            int checkflag = 1;
            while(recieved < CHUNK || sent < (no_of_childs*CHUNK)/2) {
//		printf("Process %d entered loop, turn = %d\n", rank, turn);
		checkflag = 0;
                if (turn == 0) {
			turn = 1;
		}
		else {
			turn = 0;
		}

                if (leftrecvd != -2) {// left send
                    struct TreeNode* temp = leftTreeNode[rank];
                    if(temp->left_child != NULL && temp->leftColor == turn && leftsent <= leftrecvd/2) {
                        MPI_Isend(msg+leftrecvd*CSIZE,CSIZE,MPI_CHAR,temp->left_child->process_id,leftrecvd,MPI_COMM_WORLD,&sreq[sent++]);
			leftsent++;
			checkflag = 1;
			printf("%d rank process sent %d chunk to %d rank process-a\n", rank, leftrecvd, temp->left_child->process_id);
                    }
                    else if (temp->right_child != NULL && temp->rightColor == turn && rightsent <= leftrecvd/2) {
                        MPI_Isend(msg+leftrecvd*CSIZE,CSIZE,MPI_CHAR,temp->right_child->process_id,leftrecvd,MPI_COMM_WORLD,&sreq[sent++]);
			rightsent++;
			checkflag =1;
			printf("%d rank process sent %d chunk to %d rank process-b\n", rank, leftrecvd, temp->right_child->process_id);
                    }
                }
                if (rightrecvd != -1) { // right send
                    struct TreeNode* temp = rightTreeNode[rank];
                    if(temp->left_child != NULL && temp->leftColor == turn && leftsent <= rightrecvd/2) {
                        MPI_Isend(msg+rightrecvd*CSIZE,CSIZE,MPI_CHAR,temp->left_child->process_id,rightrecvd,MPI_COMM_WORLD,&sreq[sent++]);
			leftsent++;
			checkflag = 1;
			printf("%d rank process sent %d chunk to %d rank process-c\n", rank, rightrecvd, temp->left_child->process_id);
                    }
                    else if (temp->right_child != NULL && temp->rightColor == turn && rightsent <= rightrecvd/2) {
                        MPI_Isend(msg+rightrecvd*CSIZE,CSIZE,MPI_CHAR,temp->right_child->process_id,rightrecvd,MPI_COMM_WORLD,&sreq[sent++]);
			rightsent++;
			checkflag = 1;
			printf("%d rank process sent %d chunk to %d rank process-d\n", rank, rightrecvd, temp->right_child->process_id);
                    }
                }

                // left tree
                if ((leftTreeNode[rank]->parent->left_child->process_id == rank && leftTreeNode[rank]->parent->leftColor == turn)
                 || (leftTreeNode[rank]->parent->right_child->process_id == rank && leftTreeNode[rank]->parent->rightColor == turn)) {
                   if (leftrecvd != -2) {
			 j = leftrecvd + 2;
                    if (j < CHUNK) {
			printf("Waiting: process %d waiting for packet %ld from %d\n", rank, j, leftTreeNode[rank]->parent->process_id);
                        int ierr = MPI_Recv(msg+j*CSIZE,CSIZE,MPI_CHAR,leftTreeNode[rank]->parent->process_id,j,MPI_COMM_WORLD,&stt);
                        if (ierr == MPI_SUCCESS) {
			    printf("Recieved: Process %d recieved packet %ld from %d\n", rank, j, leftTreeNode[rank]->parent->process_id);	
			    recieved += 1;
                            leftrecvd = j;
                        }
                        else {
                            printf("error recieving chunk no. %ld from left tree with node %d\n", j, rank);
                        }
			checkflag = 1;
                    }
			}
		   else {
			int flag;
			MPI_Test(&req[0], &flag, &stt);
			if (flag) {
				recieved += 1;
				leftrecvd = 0;
				printf("%d rank process recvd 0 chunk", rank);
			}	
			checkflag = 1;
	       	   }
                }
                else if ((rightTreeNode[rank]->parent->left_child->process_id == rank && rightTreeNode[rank]->parent->leftColor == turn)
                 || (rightTreeNode[rank]->parent->right_child->process_id == rank && rightTreeNode[rank]->parent->rightColor == turn)) {
                    if (rightrecvd != -1) {
			j = rightrecvd + 2;
                    if (j < CHUNK) {
			printf("Waiting: process %d waiting for packet %ld from %d\n", rank, j, rightTreeNode[rank]->parent->process_id);
                       int ierr =  MPI_Recv(msg+j*CSIZE,CSIZE,MPI_CHAR,rightTreeNode[rank]->parent->process_id,j,MPI_COMM_WORLD,&stt);
                        if (ierr == MPI_SUCCESS) {
                            printf("Recieved: Process %d recved packet %ld from %d\n", rank, j, rightTreeNode[rank]->parent->process_id);
				recieved += 1;
                            rightrecvd = j;
                        }
                        else {
                            printf("error recieving chunk no. %ld from right tree with node %d\n", j, rank);
                        }
			checkflag = 1;
                    }
		   }
		   else {
			int flag;
			MPI_Test(&req[1], &flag, &stt);
			if (flag) {
				recieved += 1;
				rightrecvd = 1;
				printf("%d rank process recvd 1 chunk\n", rank);
			}	
			checkflag = 1;
		   }
                }
            } // while loop ends
	printf("while loop ends\n");

        }// code for rank != no_of_processors ends
	printf("\n");	
	printf("Finished: Process %d finishes the task and waiting for sends to finish\n", rank);        
        MPI_Waitall(sent,sreq,sstt);  // wait for all send to finish
	MPI_Barrier(MPI_COMM_WORLD);
	printf("\n");
	printf("Computation\n");

		t2 = MPI_Wtime() - t1;
		MPI_Reduce(&t2, &res, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
		if(rank==0){
			printf("Run %ld time %1.9lf\n", i+1,res);
		} else {
			//printf("Outmsg %s Inmsg %s\n", outmsg,msg);
			j=strcmp(outmsg,msg);
			j!=0?printf("Error - msgs different\n"):0;
			memset(msg,'$',SIZE);
		}
    } // End of loop for runs
    MPI_Finalize();
*/	
    return 0;
}

